diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/ar linux-2.4.37.11-rescue//CROSS_COMPILE/ar
--- linux-2.4.37.11-orig//CROSS_COMPILE/ar	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/ar	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+ar-2.18 "$@"
diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/as linux-2.4.37.11-rescue//CROSS_COMPILE/as
--- linux-2.4.37.11-orig//CROSS_COMPILE/as	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/as	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+as-2.18 --32 "$@"
diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/gcc linux-2.4.37.11-rescue//CROSS_COMPILE/gcc
--- linux-2.4.37.11-orig//CROSS_COMPILE/gcc	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/gcc	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+gcc-3.4 -m32 "$@"
diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/ld linux-2.4.37.11-rescue//CROSS_COMPILE/ld
--- linux-2.4.37.11-orig//CROSS_COMPILE/ld	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/ld	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+ld-2.18 --architecture elf32-i386 --format elf32-i386 "$@"
diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/nm linux-2.4.37.11-rescue//CROSS_COMPILE/nm
--- linux-2.4.37.11-orig//CROSS_COMPILE/nm	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/nm	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+nm-2.18 "$@"
diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/objcopy linux-2.4.37.11-rescue//CROSS_COMPILE/objcopy
--- linux-2.4.37.11-orig//CROSS_COMPILE/objcopy	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/objcopy	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+objcopy-2.18 "$@"
diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/objdump linux-2.4.37.11-rescue//CROSS_COMPILE/objdump
--- linux-2.4.37.11-orig//CROSS_COMPILE/objdump	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/objdump	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+objdump-2.18 "$@"
diff -urN linux-2.4.37.11-orig//CROSS_COMPILE/strip linux-2.4.37.11-rescue//CROSS_COMPILE/strip
--- linux-2.4.37.11-orig//CROSS_COMPILE/strip	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//CROSS_COMPILE/strip	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+strip-2.18 "$@"
diff -urN linux-2.4.37.11-orig//depmod.pl linux-2.4.37.11-rescue//depmod.pl
--- linux-2.4.37.11-orig//depmod.pl	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//depmod.pl	2010-12-31 14:20:29.070585670 +0100
@@ -0,0 +1,292 @@
+#!/usr/bin/perl -w
+# vi: set sw=4 ts=4:
+# Copyright (c) 2001 David Schleef <ds@schleef.org>
+# Copyright (c) 2001 Erik Andersen <andersen@codepoet.org>
+# Copyright (c) 2001 Stuart Hughes <seh@zee2.com>
+# Copyright (c) 2002 Steven J. Hill <shill@broadcom.com>
+# Copyright (c) 2006 Freescale Semiconductor, Inc <stuarth@freescale.com>
+#
+# History:
+# March 2006: Stuart Hughes <stuarth@freescale.com>.
+#             Significant updates, including implementing the '-F' option
+#             and adding support for 2.6 kernels.
+
+# This program is free software; you can redistribute it and/or modify it
+# under the same terms as Perl itself.
+use Getopt::Long;
+use File::Find;
+use strict;
+
+# Set up some default values
+my $kdir="";
+my $basedir="";
+my $kernel="";
+my $kernelsyms="";
+my $symprefix="";
+my $stdout=0;
+my $verbose=0;
+my $help=0;
+my $nm = $ENV{'NM'} || "nm";
+
+# more globals
+my (@liblist) = ();
+my $exp = {};
+my $dep = {};
+my $mod = {};
+
+my $usage = <<TXT;
+$0 -b basedir { -k <vmlinux> | -F <System.map> } [options]...
+  Where:
+   -h --help          : Show this help screen
+   -b --basedir       : Modules base directory (e.g /lib/modules/<2.x.y>)
+   -k --kernel        : Kernel binary for the target (e.g. vmlinux)
+   -F --kernelsyms    : Kernel symbol file (e.g. System.map)
+   -n --stdout        : Write to stdout instead of <basedir>/modules.dep
+   -v --verbose       : Print out lots of debugging stuff
+   -P --symbol-prefix : Symbol prefix
+TXT
+
+# get command-line options
+GetOptions(
+	"help|h"            => \$help,
+	"basedir|b=s"       => \$basedir,
+	"kernel|k=s"        => \$kernel,
+	"kernelsyms|F=s"    => \$kernelsyms,
+	"stdout|n"          => \$stdout,
+	"verbose|v"         => \$verbose,
+	"symbol-prefix|P=s" => \$symprefix,
+);
+
+die $usage if $help;
+die $usage unless $basedir && ( $kernel || $kernelsyms );
+die "can't use both -k and -F\n\n$usage" if $kernel && $kernelsyms;
+
+# Strip any trailing or multiple slashes from basedir
+$basedir =~ s-(/)\1+-/-g;
+
+# The base directory should contain /lib/modules somewhere
+if($basedir !~ m-/lib/modules-) {
+    warn "WARNING: base directory does not match ..../lib/modules\n";
+}
+
+# if no kernel version is contained in the basedir, try to find one
+if($basedir !~ m-/lib/modules/\d\.\d-) {
+    opendir(BD, $basedir) or die "can't open basedir $basedir : $!\n";
+    foreach ( readdir(BD) ) {
+        next if /^\.\.?$/;
+        next unless -d "$basedir/$_";
+        warn "dir = $_\n" if $verbose;
+        if( /^\d\.\d/ ) {
+            $kdir = $_;
+            warn("Guessed module directory as $basedir/$kdir\n");
+            last;
+        }
+    }
+    closedir(BD);
+    die "Cannot find a kernel version under $basedir\n" unless $kdir;
+    $basedir = "$basedir/$kdir";
+}
+
+# Find the list of .o or .ko files living under $basedir
+warn "**** Locating all modules\n" if $verbose;
+find sub {
+    my $file;
+	if ( -f $_  && ! -d $_ ) {
+		$file = $File::Find::name;
+		if ( $file =~ /\.k?o$/ ) {
+			push(@liblist, $file);
+			warn "$file\n" if $verbose;
+		}
+	}
+}, $basedir;
+warn "**** Finished locating modules\n" if $verbose;
+
+foreach my $obj ( @liblist ){
+    # turn the input file name into a target tag name
+    my ($tgtname) = $obj =~ m-(/lib/modules/.*)$-;
+
+    warn "\nMODULE = $tgtname\n" if $verbose;
+
+    # get a list of symbols
+	my @output=`$nm $obj`;
+
+    build_ref_tables($tgtname, \@output, $exp, $dep);
+}
+
+
+# vmlinux is a special name that is only used to resolve symbols
+my $tgtname = 'vmlinux';
+my @output = $kernelsyms ? `cat $kernelsyms` : `$nm $kernel`;
+warn "\nMODULE = $tgtname\n" if $verbose;
+build_ref_tables($tgtname, \@output, $exp, $dep);
+
+# resolve the dependencies for each module
+# reduce dependencies: remove unresolvable and resolved from vmlinux/System.map
+# remove duplicates
+foreach my $module (keys %$dep) {
+    warn "reducing module: $module\n" if $verbose;
+    $mod->{$module} = {};
+    foreach (@{$dep->{$module}}) {
+        if( $exp->{$_} ) {
+            warn "resolved symbol $_ in file $exp->{$_}\n" if $verbose;
+            next if $exp->{$_} =~ /vmlinux/;
+            $mod->{$module}{$exp->{$_}} = 1;
+        } else {
+            warn "unresolved symbol $_ in file $module\n";
+        }
+    }
+}
+
+# figure out where the output should go
+if ($stdout == 0) {
+    open(STDOUT, ">$basedir/modules.dep")
+                             or die "cannot open $basedir/modules.dep: $!";
+}
+my $kseries = $basedir =~ m,/2\.6\.[^/]*, ? '2.6' : '2.4';
+
+foreach my $module ( keys %$mod ) {
+    if($kseries eq '2.4') {
+	    print "$module:\t";
+	    my @sorted = sort bydep keys %{$mod->{$module}};
+	    print join(" \\\n\t",@sorted);
+	    print "\n\n";
+    } else {
+	    print "$module: ";
+	    my @sorted = sort bydep keys %{$mod->{$module}};
+	    print join(" ",@sorted);
+	    print "\n";
+    }
+}
+
+
+sub build_ref_tables
+{
+    my ($name, $sym_ar, $exp, $dep) = @_;
+
+	my $ksymtab = grep m/ __ksymtab/, @$sym_ar;
+
+    # gather the exported symbols
+	if($ksymtab){
+        # explicitly exported
+        foreach ( @$sym_ar ) {
+            / __ksymtab_(.*)$/ and do {
+                warn "sym = $1\n" if $verbose;
+                $exp->{$1} = $name;
+            };
+        }
+	} else {
+        # exporting all symbols
+        foreach ( @$sym_ar ) {
+            / [ABCDGRST] (.*)$/ and do {
+                warn "syma = $1\n" if $verbose;
+                $exp->{$1} = $name;
+            };
+        }
+	}
+
+    # this takes makes sure modules with no dependencies get listed
+    push @{$dep->{$name}}, $symprefix . 'printk' unless $name eq 'vmlinux';
+
+    # gather the unresolved symbols
+    foreach ( @$sym_ar ) {
+        !/ __this_module/ && / U (.*)$/ and do {
+            warn "und = $1\n" if $verbose;
+            push @{$dep->{$name}}, $1;
+        };
+    }
+}
+
+sub bydep
+{
+    foreach my $f ( keys %{$mod->{$b}} ) {
+        if($f eq $a) {
+            return 1;
+        }
+    }
+    return -1;
+}
+
+
+
+__END__
+
+=head1 NAME
+
+depmod.pl - a cross platform script to generate kernel module
+dependency lists (modules.conf) which can then be used by modprobe
+on the target platform.
+
+It supports Linux 2.4 and 2.6 styles of modules.conf (auto-detected)
+
+=head1 SYNOPSIS
+
+depmod.pl [OPTION]... [basedir]...
+
+Example:
+
+	depmod.pl -F linux/System.map -b target/lib/modules/2.6.11
+
+=head1 DESCRIPTION
+
+The purpose of this script is to automagically generate a list of of kernel
+module dependencies.  This script produces dependency lists that should be
+identical to the depmod program from the modutils package.  Unlike the depmod
+binary, however, depmod.pl is designed to be run on your host system, not
+on your target system.
+
+This script was written by David Schleef <ds@schleef.org> to be used in
+conjunction with the BusyBox modprobe applet.
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-h --help>
+
+This displays the help message.
+
+=item B<-b --basedir>
+
+The base directory uner which the target's modules will be found.  This
+defaults to the /lib/modules directory.
+
+If you don't specify the kernel version, this script will search for
+one under the specified based directory and use the first thing that
+looks like a kernel version.
+
+=item B<-k --kernel>
+
+Kernel binary for the target (vmlinux).  You must either supply a kernel binary
+or a kernel symbol file (using the -F option).
+
+=item B<-F --kernelsyms>
+
+Kernel symbol file for the target (System.map).
+
+=item B<-n --stdout>
+
+Write to stdout instead of modules.dep
+kernel binary for the target (using the -k option).
+
+=item B<--verbose>
+
+Verbose (debug) output
+
+=back
+
+=head1 COPYRIGHT AND LICENSE
+
+ Copyright (c) 2001 David Schleef <ds@schleef.org>
+ Copyright (c) 2001 Erik Andersen <andersen@codepoet.org>
+ Copyright (c) 2001 Stuart Hughes <seh@zee2.com>
+ Copyright (c) 2002 Steven J. Hill <shill@broadcom.com>
+ Copyright (c) 2006 Freescale Semiconductor, Inc <stuarth@freescale.com>
+
+This program is free software; you can redistribute it and/or modify it
+under the same terms as Perl itself.
+
+=head1 AUTHOR
+
+David Schleef <ds@schleef.org>
+
+=cut
diff -urN linux-2.4.37.11-orig//drivers/block/loop.c linux-2.4.37.11-rescue//drivers/block/loop.c
--- linux-2.4.37.11-orig//drivers/block/loop.c	2010-09-06 07:37:37.000000000 +0200
+++ linux-2.4.37.11-rescue//drivers/block/loop.c	2010-12-31 14:20:29.073587351 +0100
@@ -78,7 +78,7 @@
 
 #define MAJOR_NR LOOP_MAJOR
 
-static int max_loop = 8;
+static int max_loop = 256;
 static struct loop_device *loop_dev;
 static int *loop_sizes;
 static int *loop_blksizes;
diff -urN linux-2.4.37.11-orig//fs/Makefile linux-2.4.37.11-rescue//fs/Makefile
--- linux-2.4.37.11-orig//fs/Makefile	2010-09-06 07:37:37.000000000 +0200
+++ linux-2.4.37.11-rescue//fs/Makefile	2010-12-31 14:20:29.073587351 +0100
@@ -32,9 +32,13 @@
 subdir-$(CONFIG_INTERMEZZO_FS)	+= intermezzo
 subdir-$(CONFIG_MINIX_FS)	+= minix
 subdir-$(CONFIG_FAT_FS)		+= fat
+# For umsdos being able to be the root filesystem, vfat should be put after 
+# umsdos and msdos. But this is not really comfortable since one mounts more
+# vfat-filesystems than umsdos-roots. If umsdos is really needed to be the 
+# root-filesystem one should use the boot option: rootfstype=umsdos.
+subdir-$(CONFIG_VFAT_FS)	+= vfat
 subdir-$(CONFIG_UMSDOS_FS)	+= umsdos
 subdir-$(CONFIG_MSDOS_FS)	+= msdos
-subdir-$(CONFIG_VFAT_FS)	+= vfat
 subdir-$(CONFIG_BFS_FS)		+= bfs
 subdir-$(CONFIG_ISO9660_FS)	+= isofs
 subdir-$(CONFIG_DEVFS_FS)	+= devfs
diff -urN linux-2.4.37.11-orig//init/do_mounts.c linux-2.4.37.11-rescue//init/do_mounts.c
--- linux-2.4.37.11-orig//init/do_mounts.c	2010-09-06 07:37:37.000000000 +0200
+++ linux-2.4.37.11-rescue//init/do_mounts.c	2010-12-31 14:20:29.073587351 +0100
@@ -905,7 +905,11 @@
 		ssleep(root_delay);
 	}
 
-	is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;
+//	is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;
+        is_floppy = (MAJOR(ROOT_DEV) == FLOPPY_MAJOR ||
+                    (MAJOR(ROOT_DEV) == SCSI_DISK0_MAJOR &&
+                    MINOR(ROOT_DEV) == 0));
+
 #ifdef CONFIG_ALL_PPC
 	extern void arch_discover_root(void);
 	arch_discover_root();
diff -urN linux-2.4.37.11-orig//Makefile linux-2.4.37.11-rescue//Makefile
--- linux-2.4.37.11-orig//Makefile	2010-12-31 14:10:06.000000000 +0100
+++ linux-2.4.37.11-rescue//Makefile	2010-12-31 14:20:48.253585601 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 37
-EXTRAVERSION = .11
+EXTRAVERSION = .11-rescue
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
@@ -19,7 +19,8 @@
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-CROSS_COMPILE 	=
+SHELL		= /bin/sh
+CROSS_COMPILE 	= $(SHELL) $(TOPDIR)/CROSS_COMPILE/
 
 #
 # Include the make variables (CC, etc...)
@@ -35,12 +36,12 @@
 OBJCOPY		= $(CROSS_COMPILE)objcopy
 OBJDUMP		= $(CROSS_COMPILE)objdump
 MAKEFILES	= $(TOPDIR)/.config
-GENKSYMS	= /sbin/genksyms
-DEPMOD		= /sbin/depmod
+GENKSYMS	= $(TOPDIR)/modutils/genksyms
 MODFLAGS	= -DMODULE
 CFLAGS_KERNEL	=
 PERL		= perl
 AWK		= awk
+DEPMOD		= $(PERL) $(TOPDIR)/depmod.pl
 RPM 		:= $(shell if [ -x "/usr/bin/rpmbuild" ]; then echo rpmbuild; \
 		    	else echo rpm; fi)
 
@@ -91,7 +92,7 @@
 
 CPPFLAGS := -D__KERNEL__ -I$(HPATH)
 
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -O2 \
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
 	  -fno-strict-aliasing -fno-common
 CFLAGS += -fno-builtin-strpbrk -fno-builtin-sprintf
 ifndef CONFIG_FRAME_POINTER
@@ -115,7 +116,7 @@
 # This is i386 specific.
 #
 
-export ROOT_DEV = CURRENT
+export ROOT_DEV = 
 
 #
 # If you want to preset the SVGA mode, uncomment the next line and
@@ -428,14 +429,15 @@
 # vmlinux.  This depmod is only for convenience to give the initial
 # boot a modules.dep even before / is mounted read-write.  However the
 # boot script depmod is the master version.
-ifeq "$(strip $(INSTALL_MOD_PATH))" ""
-depmod_opts	:=
-else
-depmod_opts	:= -b $(INSTALL_MOD_PATH) -r
-endif
+#ifeq "$(strip $(INSTALL_MOD_PATH))" ""
+$(strip $(INSTALL_MOD_PATH))
+#depmod_opts	:= 
+#else
+depmod_opts	:= -b $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE) > $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)/modules.dep
+#endif
 .PHONY: _modinst_post
 _modinst_post: _modinst_post_pcmcia
-	if [ -r System.map ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
+	if [ -r System.map ]; then $(DEPMOD) -F System.map $(depmod_opts) > /dev/null 2>&1; fi
 
 # Backwards compatibilty symlinks for people still using old versions
 # of pcmcia-cs with hard coded pathnames on insmod.  Remove
@@ -469,7 +471,7 @@
 	rm -rf $(CLEAN_DIRS)
 	$(MAKE) -C Documentation/DocBook clean
 
-mrproper: clean archmrproper
+mrproper: clean archmrproper genksyms-clean
 	find . \( -size 0 -o -name .depend \) -type f -print | xargs rm -f
 	rm -f $(MRPROPER_FILES)
 	rm -rf $(MRPROPER_DIRS)
@@ -524,7 +526,13 @@
 endif
 export	MODVERFILE
 
-depend dep: dep-files
+depend dep: genksyms dep-files
+
+genksyms:
+	{ cd $(TOPDIR)/modutils; make; }
+
+genksyms-clean:
+	{ cd $(TOPDIR)/modutils; make clean; }
 
 checkconfig:
 	find * -name '*.[hcS]' -type f -print | sort | xargs $(PERL) -w scripts/checkconfig.pl
diff -urN linux-2.4.37.11-orig//modutils/alias.h linux-2.4.37.11-rescue//modutils/alias.h
--- linux-2.4.37.11-orig//modutils/alias.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/alias.h	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,317 @@
+/*
+ * This file is split out from config.c for easier editing
+ */
+
+/*
+ * tbpath and tbtype are used to build the complete set of paths for finding
+ * modules, but only when we search for individual directories, they are not
+ * used for [boot] and [toplevel] searches.
+ */
+static char *tbpath[] =
+{
+	"/lib/modules",
+	NULL			/* marks the end of the list! */
+};
+
+char *tbtype[] =
+{
+	"kernel",		/* as of 2.3.14 this must be first */
+	"fs",
+	"net",
+	"scsi",
+	"block",
+	"cdrom",
+	"ipv4",
+	"ipv6",
+	"sound",
+	"fc4",
+	"video",
+	"misc",
+	"pcmcia",
+	"atm",
+	"usb",
+	"ide",
+	"ieee1394",
+	"mtd",
+	NULL			/* marks the end of the list! */
+};
+
+/*
+ * This is the list of pre-defined aliases.
+ * Each entry can be overridden by an entry in /etc/modules.conf
+ */
+char *aliaslist[] =
+{
+	"binfmt-0000 off",
+	"binfmt-204 binfmt_aout",
+	"binfmt-263 binfmt_aout",
+	"binfmt-264 binfmt_aout",
+	"binfmt-267 binfmt_aout",
+	"binfmt-387 binfmt_aout",
+	"binfmt-332 iBCS",
+	"binfmt--310 binfmt_java",
+
+	"block-major-1 rd",
+	"block-major-2 floppy",
+	"block-major-3 ide-probe-mod",
+	"block-major-7 loop",
+	"block-major-8 sd_mod",
+	"block-major-9 md", /* For modular RAID */
+	"block-major-11 sr_mod",
+	"block-major-13 xd",
+	"block-major-15 cdu31a",
+	"block-major-16 gscd",
+	"block-major-17 optcd",
+	"block-major-18 sjcd",
+	"block-major-20 mcdx",
+	"block-major-22 ide-probe-mod",
+	"block-major-23 mcd",
+	"block-major-24 sonycd535",
+	"block-major-25 sbpcd",
+	"block-major-26 sbpcd",
+	"block-major-27 sbpcd",
+	"block-major-29 aztcd",
+	"block-major-32 cm206",
+	"block-major-33 ide-probe-mod",
+	"block-major-34 ide-probe-mod",
+	"block-major-37 ide-tape",
+	"block-major-44 ftl",		/* from David Woodhouse <dwmw2@infradead.org> */
+	"block-major-46 pcd",
+	"block-major-47 pf",
+	"block-major-56 ide-probe-mod",
+	"block-major-57 ide-probe-mod",
+	"block-major-58 lvm-mod",
+	"block-major-88 ide-probe-mod",
+	"block-major-89 ide-probe-mod",
+	"block-major-90 ide-probe-mod",
+	"block-major-91 ide-probe-mod",
+	"block-major-93 nftl",		/* from David Woodhouse <dwmw2@infradead.org> */
+	"block-major-97 pg",
+	"block-major-113 viocd",
+
+#if !defined(__s390__) && !defined(__s390x__)
+	"char-major-4 serial",
+#else
+ 	"char-major-4 off",
+#endif
+	"char-major-5 serial",
+	"char-major-6 lp",
+	"char-major-9 st",
+	"char-major-10 off",		/* was: mouse, was: misc */
+	"char-major-10-0 busmouse",	/* /dev/logibm Logitech bus mouse */
+	"char-major-10-1 off",		/* /dev/psaux PS/2-style mouse port */
+	"char-major-10-2 msbusmouse",	/* /dev/inportbm Microsoft Inport bus mouse */
+	"char-major-10-3 atixlmouse",	/* /dev/atibm ATI XL bus mouse */
+					/* /dev/jbm J-mouse */
+					/* /dev/amigamouse Amiga mouse (68k/Amiga) */
+					/* /dev/atarimouse Atari mouse */
+					/* /dev/sunmouse Sun mouse */
+					/* /dev/beep Fancy beep device */
+					/* /dev/modreq Kernel module load request */
+	"char-major-10-130 wdt",	/* /dev/watchdog Watchdog timer port */
+	"char-major-10-131 wdt",	/* /dev/temperature Machine internal temperature */
+					/* /dev/hwtrap Hardware fault trap */
+					/* /dev/exttrp External device trap */
+	"char-major-10-135 rtc",	/* /dev/rtc Real time clock */
+	"char-major-10-139 openprom",	/* /dev/openprom Linux/Sparc interface */
+	"char-major-10-144 nvram",	/* from Tigran Aivazian <tigran@sco.COM> */
+	"char-major-10-157 applicom",	/* from David Woodhouse <dwmw2@infradead.org> */
+	"char-major-10-175 agpgart",    /* /dev/agpgart GART AGP mapping access */
+	"char-major-10-184 microcode",	/* Tigran Aivazian <tigran@veritas.com> */
+	"char-major-10-200 tun",	/* Universal TUN/TAP device driver */
+	"char-major-10-250 hci_vhci",
+
+	"char-major-13 input",
+	"char-major-13-0 joydev",
+	"char-major-13-32 mousedev",
+	"char-major-14 soundcore",
+	"char-major-19 cyclades",
+	"char-major-20 cyclades",
+	"char-major-21 sg",
+	"char-major-22 pcxx", /* ?? */
+	"char-major-23 pcxx", /* ?? */
+	"char-major-27 zftape",
+	"char-major-34 scc",
+	"char-major-35 tclmidi",
+	"char-major-36 netlink",
+	"char-major-37 ide-tape",
+	"char-major-48 riscom8",
+	"char-major-49 riscom8",
+	"char-major-57 esp",
+	"char-major-58 esp",
+	"char-major-63 kdebug",
+	"char-major-90 mtdchar",	/* from David Woodhouse <dwmw2@infradead.org> */
+	"char-major-96 pt",
+	"char-major-99 ppdev",
+	"char-major-107 3dfx", /* from Tigran Aivazian <tigran@sco.COM> */
+	"char-major-108 ppp_generic",
+	"char-major-109 lvm-mod",
+	"char-major-161 ircomm-tty",
+	"char-major-171 raw1394",
+	"char-major-195 NVdriver",
+	"char-major-200 vxspec",
+	"char-major-206 osst",  /* OnStream SCSI tape */
+	"char-major-216 rfcomm",
+
+	"dos msdos",
+	"dummy0 dummy",
+	"dummy1 dummy",
+	"eth0 off",
+	"iso9660 isofs",
+	"md-personality-1 linear",
+	"md-personality-2 raid0",
+	"md-personality-3 raid1",
+	"md-personality-4 raid5",
+	"md-personality-7 multipath",
+
+	"net-pf-1 unix",	/* PF_UNIX	1  Unix domain sockets */
+	"net-pf-2 ipv4",	/* PF_INET	2  Internet IP Protocol */
+	"net-pf-3 off",		/* PF_AX25	3  Amateur Radio AX.25 */
+	"net-pf-4 ipx",		/* PF_IPX	4  Novell IPX */
+	"net-pf-5 appletalk",	/* PF_APPLETALK	5  Appletalk DDP */
+	"net-pf-6 off",		/* PF_NETROM	6  Amateur radio NetROM */
+				/* PF_BRIDGE	7  Multiprotocol bridge */
+				/* PF_AAL5	8  Reserved for Werner's ATM */
+				/* PF_X25	9  Reserved for X.25 project */
+	"net-pf-10 off",	/* PF_INET6	10 IP version 6 */
+	"net-pf-15 af_key",	/* PF_KEY       15 Key Management API */
+
+	/* next two from <dairiki@matthews.dairiki.org>  Thanks! */
+	"net-pf-17 af_packet",
+	"net-pf-19 off",	/* acorn econet */
+	
+	"net-pf-31 bluez",
+
+	"netalias-2 ip_alias",
+
+	/* To be able to attach some dongles */
+	"irlan0 irlan",
+	"irda-dongle-0 tekram",
+	"irda-dongle-1 esi",
+	"irda-dongle-2 actisys",
+	"irda-dongle-3 actisys",
+	"irda-dongle-4 girbil",
+	"irda-dongle-5 litelink",
+	"irda-dongle-6 airport",
+	"irda-dongle-7 old_belkin",
+	 
+	"bt-proto-0 l2cap",
+	"bt-proto-2 sco",
+	"bt-proto-3 rfcomm",
+	"bt-proto-4 bnep",
+
+	"plip0 plip",
+	"plip1 plip",
+	"tunl0 ipip",
+	"cipcb0 cipcb",
+	"cipcb1 cipcb",
+	"cipcb2 cipcb",
+	"cipcb3 cipcb",
+#if	defined(__s390__) || defined(__s390x__)
+	"ctc0 ctc",
+	"ctc1 ctc",
+	"ctc2 ctc",
+	"iucv0 netiucv",
+	"iucv1 netiucv",
+#endif
+	"ppp0 ppp",
+	"ppp1 ppp",
+	"scsi_hostadapter off",	/* if not in config file */
+	"slip0 slip",
+	"slip1 slip",
+	"tty-ldisc-1 slip",
+	"tty-ldisc-3 ppp_async",
+	"tty-ldisc-11 irtty", /* IrDA over a normal serial port, or a serial port compatible IrDA port */
+	"tty-ldisc-14 ppp_synctty",
+	"tty-ldisc-15 hci_uart",
+	"ppp-compress-18 ppp_mppe",
+	"ppp-compress-21 bsd_comp",
+	"ppp-compress-24 ppp_deflate",
+	"ppp-compress-26 ppp_deflate",
+
+#ifndef __sparc__
+	"parport_lowlevel parport_pc",
+#else
+	"parport_lowlevel parport_ax",
+#endif
+
+	"usbdevfs usbcore",
+
+	"xfrm-type-2-50 esp4",
+	"xfrm-type-2-51 ah4",
+	"xfrm-type-2-108 ipcomp",
+	"xfrm-type-10-50 esp6",
+	"xfrm-type-10-51 ah6",
+	"xfrm-type-10-108 ipcomp6",
+
+	"cipher_null crypto_null",
+	"digest_null crypto_null",
+	"compress_null crypto_null",
+	"sha384 sha512",
+
+	NULL			/* marks the end of the list! */
+};
+
+/*
+ * This is the list of pre-defined options.
+ * Each entry can be overridden by an entry in /etc/modules.conf
+ */
+char *optlist[] =
+{
+	"dummy0 -o dummy0",
+	"dummy1 -o dummy1",
+	"sb io=0x220 irq=7 dma=1 dma16=5 mpu_io=0x330",
+	NULL			/* marks the end of the list! */
+};
+
+/*
+ * This is the list of pre-defined "above"s,
+ * used for pull-in of additional modules
+ * Each entry can be overridden by an entry in /etc/modules.conf
+ */
+char *above[] =
+{
+	"hid keybdev mousedev",
+	"usbmouse hid",
+	"wacom evdev",
+	NULL			/* marks the end of the list! */
+};
+
+/*
+ * This is the list of pre-defined "below"s,
+ * used for push-in of additional modules
+ * Each entry can be overridden by an entry in /etc/modules.conf
+ */
+char *below[] =
+{
+	"ov518_decomp ov511",
+	NULL			/* marks the end of the list! */
+};
+
+/*
+ * This is the list of pre-defined "prune"s,
+ * used to exclude paths from scan of /lib/modules.
+ * /etc/modules.conf can add entries but not remove them.
+ */
+char *prune[] =
+{
+	"modules.dep",
+	"modules.description",
+	"modules.generic_string",
+	"modules.pcimap",
+	"modules.isapnpmap",
+	"modules.usbmap",
+	"modules.parportmap",
+	"modules.ieee1394map",
+	"modules.pnpbiosmap",
+	"System.map",
+	".config",
+	"Kerntypes",
+	"build",		/* symlink to source tree */
+	"vmlinux",
+	"vmlinuz",
+	"bzImage",
+	"zImage",
+	".rhkmvtag",		/* wish RedHat had told me before they did this */
+	NULL			/* marks the end of the list! */
+};
diff -urN linux-2.4.37.11-orig//modutils/arch64.c linux-2.4.37.11-rescue//modutils/arch64.c
--- linux-2.4.37.11-orig//modutils/arch64.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/arch64.c	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,43 @@
+/* Misc utility functions.
+   Copyright 1996, 1997 Linux International.
+   Written by Keith Owens <kaos@ocs.com.au>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/utsname.h>
+#include "util.h"
+
+/*======================================================================*/
+
+/* Indicate if the current machine uses 64 bit architecture */
+int arch64(void)
+{
+	struct utsname uts;
+	char *uname_m;
+	if (uname(&uts))
+		return(0);
+	if ((uname_m = getenv("UNAME_MACHINE"))) {
+		int l = strlen(uname_m);
+		if (l >= sizeof(uts.machine))
+			l = sizeof(uts.machine)-1;
+		memcpy(uts.machine, uname_m, l);
+		uts.machine[l] = '\0';
+	}
+	return(strstr(uts.machine, "64") != NULL || strstr(uts.machine, "s390x") != NULL);
+}
diff -urN linux-2.4.37.11-orig//modutils/config.c linux-2.4.37.11-rescue//modutils/config.c
--- linux-2.4.37.11-orig//modutils/config.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/config.c	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,1666 @@
+/*
+ * Handle the configuration, including /etc/modules.conf
+ *
+ * Copyright 1994, 1995, 1996, 1997:
+ *	Jacques Gelinas <jack@solucorp.qc.ca>
+ *	Björn Ekwall <bj0rn@blox.se> February 1999
+ *	Keith Owens <kaos@ocs.com.au> October 1999
+ *
+ * "kernelversion" idea from the Debian release via:
+ *      Wichert Akkerman <wakkerma@cs.leidenuniv.nl>
+ *
+ * Björn, inspired by Richard Henderson <rth@twiddle.net>, cleaned up
+ * the wildcard handling and started using ftw in March 1999
+ * Cleanup of hardcoded arrays: Björn Ekwall <bj0rn@blox.se> March 1999
+ * Many additional keywords: Björn Ekwall <bj0rn@blox.se> (C) March 1999
+ * Standardize on /etc/modules.conf Keith Owens <kaos@ocs.com.au> October 1999
+ *
+ * Alpha typecast:Michal Jaegermann <michal@ellpspace.math.ualberta.ca>
+ *
+ * This file is part of the Linux modutils.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Specification: /etc/modules.conf / format
+ *	Modules may be located at different places in the filesystem.
+ *
+ *	The file /etc/modules.conf contains different definitions to
+ *	control the manipulation of modules.
+ *
+ *	Standard Unix style comments and continuation line are supported.
+ *	Comments begin with a # and continue until the end of the line.
+ *	A line continues on the next one if the last non-white character
+ *	is a \.
+ */
+/* #Specification: /etc/modules.conf / format / official name */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include <signal.h>
+#include <limits.h>
+#include <sys/param.h>
+#include <errno.h>
+
+#include "util.h"
+#include "config.h"
+#include "alias.h"
+
+int flag_autoclean; /* set/used by modprobe and insmod */
+
+struct utsname uts_info;
+
+struct PATH_TYPE *modpath;
+int nmodpath = 0;
+static int maxpath = 0;
+
+struct EXEC_TYPE *execs;
+int nexecs = 0;
+static int maxexecs = 0;
+
+OPT_LIST *opt_list;
+static int n_opt_list;
+
+OPT_LIST *abovelist;
+static int n_abovelist;
+
+OPT_LIST *belowlist;
+static int n_belowlist;
+
+OPT_LIST *prunelist;
+static int n_prunelist;
+
+OPT_LIST *probe_list;
+static int n_probe_list;
+
+OPT_LIST *probeall_list;
+static int n_probeall_list;
+
+OPT_LIST *aliases;
+static int n_aliases;
+
+char *persistdir = "/var/lib/modules/persist";
+
+const char symprefix[] = SYMPREFIX;
+
+char *insmod_opt = NULL;
+char *config_file = NULL;	/* Which file was actually used */
+time_t config_mtime;
+int root_check_off = CONFIG_ROOT_CHECK_OFF;	/* Default is modules must be owned by root */
+static char *config_version;	/* Hack for config_add */
+int quick = 0;			/* Option -A */
+
+/* The initialization order must match the gen_file_enum order in config.h */
+struct gen_files gen_file[] = {
+	{"generic_string", NULL, 0},
+	{"pcimap", NULL, 0},
+	{"isapnpmap", NULL, 0},
+	{"usbmap", NULL, 0},
+	{"parportmap", NULL, 0},
+	{"ieee1394map", NULL, 0},
+	{"pnpbiosmap", NULL, 0},
+	{"dep", NULL, 0},
+};
+
+const int gen_file_count = sizeof(gen_file)/sizeof(gen_file[0]);
+
+int flag_verbose;
+
+unsigned long safemode;
+
+void verbose(const char *ctl,...)
+{
+	if (flag_verbose) {
+		va_list list;
+		va_start(list, ctl);
+		vprintf(ctl, list);
+		va_end(list);
+		fflush(stdout);
+	}
+}
+
+
+/*
+ *	Check to see if the existing modules.xxx files need updating,
+ *	based on the timestamps of the modules and the config file.
+ */
+static int check_update (const char *file, const struct stat *sb)
+{
+	int len = strlen(file);
+	int i;
+
+	if (!S_ISREG(sb->st_mode))
+		return 0;
+	for (i = 0; i < gen_file_count; ++i) {
+		if (sb->st_mtime > gen_file[i].mtime)
+			break;
+	}
+	if (i == gen_file_count)
+		return 0;	/* All generated files are up to date */
+
+	if (len > 2 && !strcmp(file + len - 2, ".o"))
+		return 1;
+	else if (len > 4 && !strcmp(file + len - 4, ".mod"))
+		return 1;
+#ifdef CONFIG_USE_ZLIB
+	else if (len > 5 && !strcmp(file + len - 5, ".o.gz"))
+		return 1;
+#endif
+	return 0;
+}
+
+static int need_update (const char *force_ver, const char *base_dir)
+{
+	struct stat tmp;
+	char dep[PATH_MAX];
+	int i;
+	uname (&uts_info);
+	if (!force_ver)
+		force_ver = uts_info.release;
+
+	if (strlen (force_ver) > 50)
+		/* That's just silly. */
+		return 1;
+
+	for (i = 0; i < gen_file_count; ++i) {
+		if (stat(gen_file[i].name, &tmp))
+			return 1;	/* No dependency file yet, so we need to build it. */
+		gen_file[i].mtime = tmp.st_mtime;
+	}
+
+	if (stat ("/etc/modules.conf", &tmp) &&
+	    stat ("/etc/conf.modules", &tmp))
+		return 1;
+
+	for (i = 0; i < gen_file_count; ++i) {
+		if (tmp.st_mtime > gen_file[i].mtime)
+			return 1;	/* Config file is newer. */
+	}
+
+	snprintf (dep, sizeof(dep), "%s/lib/modules/%s", base_dir, force_ver);
+	return xftw (dep, check_update);
+}
+
+
+/*
+ *	Strip white char at the end of a string.
+ *	Return the address of the last non white char + 1 (point on the '\0').
+ */
+static char *strip_end(char *str)
+{
+	int len = strlen(str);
+
+	for (str += len - 1; len > 0 && (isspace(*str)); --len, --str)
+		*str = '\0';
+	return str + 1;
+}
+
+/*
+ *	Read a line using fgets, expanding the buffer as necessary until \n is
+ *	seen.  If *p_buf is NULL the sizebuf is ignored, otherwise sizebuf must
+ *	contain the malloc() size of *p_buf.
+ */
+static char *fgets_local(char **p_buf, int *sizebuf, FILE * fin)
+{
+	char *p;
+	char *ret = NULL;
+	if (!*p_buf)
+		*p_buf = xmalloc(*sizebuf = 3000);
+	**p_buf = '\0';
+	p = *p_buf;
+	while (1) {
+		ret = fgets(p, *p_buf + *sizebuf - p, fin);
+		if (!ret || strrchr(p, '\n'))
+			break;
+		*p_buf = xrealloc(*p_buf, *sizebuf + 3000);
+		p = *p_buf + *sizebuf - 1;
+		*sizebuf += 3000;
+	}
+	if (**p_buf)
+		ret = *p_buf;
+	return ret;
+}
+
+/*
+ *	Read a line of a configuration file and process continuation lines.
+ *	Return buf, or NULL if EOF.
+ *	Blank at the end of line are always stripped.
+ *	Everything on a line following comchar is a comment.
+ *
+ *	Continuation character is \
+ *	Comment character is #
+ */
+char *fgets_strip(char **p_buf, int *sizebuf, FILE * fin, int *lineno)
+{
+	char *ret = NULL;
+	char *buf;
+	char *buf_prev = NULL;
+	char comchar = '#';
+	char contchar = '\\';
+
+
+	while ((buf = fgets_local(p_buf, sizebuf, fin)) != NULL) {
+		char *start = buf;
+		char *end = strip_end(buf);
+		char *pt = strchr(buf, comchar);
+
+		if (pt != NULL) {
+			*pt = '\0';
+			end = strip_end(buf);
+		}
+
+		if (lineno != NULL)
+			(*lineno)++;
+		ret = start;
+		if (buf_prev) {
+			/* this is a continuation line, append to the previous
+			 * buffer which becomes the current buffer.  White space
+			 * at the start of the continuation line is replaced by
+			 * a single space.
+			 */
+			int buf_prev_len = strlen(buf_prev);
+			buf_prev = xrealloc(buf_prev, buf_prev_len + *sizebuf);
+			memcpy(buf_prev + buf_prev_len, *p_buf, *sizebuf);
+			*sizebuf += buf_prev_len;
+			free(*p_buf);
+			*p_buf = buf_prev;
+			buf_prev = NULL;
+			buf = *p_buf + buf_prev_len;
+			pt = buf;
+			start = buf;
+			end = strip_end(buf);
+			while (isspace(*pt))
+				pt++;
+			if (pt > buf + 1) {
+				strcpy(buf + 1, pt);	/* safe, backward copy */
+				buf[0] = ' ';
+				end -= (int) (pt - buf) - 1;
+			} else if (pt == buf + 1) {
+				buf[0] = ' ';
+			}
+		}
+		if (end > buf && *(end - 1) == contchar) {
+			if (end == buf + 1 || *(end - 2) != contchar) {
+				/* Continuation */
+				end--;
+				*end = '\0';
+				buf_prev = *p_buf;
+				*p_buf = NULL;
+			} else {
+				*(end - 1) = '\0';
+				break;
+			}
+		} else {
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static char *next_word(char *pt)
+{
+	char *match;
+	char *pt2;
+
+	/* find end of word */
+	for (pt2 = pt; *pt2 && !(isspace(*pt2)); ++pt2) {
+		if ((match = strchr("\"'`", *pt2)) != NULL) {
+			for (++pt2; *pt2 && *pt2 != *match; ++pt2) {
+				if (*pt2 == '\\' && *(pt2 + 1) == *match)
+					++pt2;
+			}
+		}
+	}
+
+	/* skip leading whitespace before next word */
+	if (*pt2) {
+		*pt2++ = '\0'; /* terminate last word */
+		while (*pt2 && isspace(*pt2))
+			++pt2;
+	}
+	return pt2;
+}
+
+static GLOB_LIST *addlist(GLOB_LIST *orig, GLOB_LIST *add)
+{
+	if (!orig)
+		return add;
+	/* else */
+	orig->pathv = (char **)xrealloc(orig->pathv,
+					(orig->pathc + add->pathc + 1) *
+					sizeof(char *));
+	memcpy(orig->pathv + orig->pathc, add->pathv,
+	       add->pathc * sizeof(char *));
+	orig->pathc += add->pathc;
+	orig->pathv[orig->pathc] = NULL;
+	/*
+	free(add->pathv);
+	free(add);
+	*/
+	return orig;
+}
+
+static void decode_list(int *n, OPT_LIST **list, char *arg, int adding,
+			char *version, int opts)
+{
+	GLOB_LIST *pg;
+	GLOB_LIST *prevlist = NULL;
+	int i, autoclean = 1;
+	int where = *n;
+	char *arg2 = next_word(arg);
+
+	if (opts && !strcmp (arg, "-k")) {
+		if (!*arg2)
+			error("Missing module argument after -k\n");
+		arg = arg2;
+		arg2 = next_word(arg);
+		autoclean = 0;
+	}
+
+	for (i = 0; i < *n; ++i) {
+		if (strcmp((*list)[i].name, arg) == 0) {
+			if (adding)
+				prevlist = (*list)[i].opts;
+			else
+				free((*list)[i].opts);
+			(*list)[i].opts = NULL;
+			where = i;
+			break;
+		}
+	}
+	if (where == *n) {
+		(*list) = (OPT_LIST *)xrealloc((*list),
+			  (*n + 2) * sizeof(OPT_LIST));
+		(*list)[*n].name = xstrdup(arg);
+		(*list)[*n].autoclean = autoclean;
+		*n += 1;
+		memset(&(*list)[*n], 0, sizeof(OPT_LIST));
+	} else if (!autoclean)
+		(*list)[where].autoclean = 0;
+	pg = (GLOB_LIST *)xmalloc(sizeof(GLOB_LIST));
+	meta_expand(arg2, pg, NULL, version, ME_ALL);
+	(*list)[where].opts = addlist(prevlist, pg);
+}
+
+static void decode_exec(char *arg, int type)
+{
+	char *arg2;
+
+	execs[nexecs].when = type;
+	arg2 = next_word(arg);
+	execs[nexecs].module = xstrdup(arg);
+	execs[nexecs].cmd = xstrdup(arg2);
+	if (++nexecs >= maxexecs) {
+		maxexecs += 10;
+		execs = (struct EXEC_TYPE *)xrealloc(execs,
+			maxexecs * sizeof(struct EXEC_TYPE));
+	}
+}
+
+static int build_list(char **in, OPT_LIST **out, char *version, int opts)
+{
+	GLOB_LIST *pg;
+	int i;
+
+	for (i = 0; in[i]; ++i) {
+		char *p = xstrdup(in[i]);
+		char *pt = next_word(p);
+		char *pn = p;
+
+		*out = (OPT_LIST *)xrealloc(*out, (i + 2) * sizeof(OPT_LIST));
+		(*out)[i].autoclean = 1;
+		if (opts && !strcmp (p, "-k")) {
+		    pn = pt;
+		    pt = next_word(pn);
+		    (*out)[i].autoclean = 0;
+		}
+		pg = (GLOB_LIST *)xmalloc(sizeof(GLOB_LIST));
+		meta_expand(pt, pg, NULL, version, ME_ALL);
+		(*out)[i].name = xstrdup(pn);
+		(*out)[i].opts = pg;
+		free(p);
+	}
+	memset(&(*out)[i], 0, sizeof(OPT_LIST));
+
+	return i;
+}
+
+/* Environment variables can override defaults, testing only */
+static void gen_file_env(struct gen_files *gf)
+{
+	if (!safemode) {
+		char *e = xmalloc(strlen(gf->base)+5), *p1 = gf->base, *p2 = e;
+		while ((*p2++ = toupper(*p1++))) ;
+		strcpy(p2-1, "PATH");	/* safe, xmalloc */
+		if ((p2 = getenv(e)) != NULL) {
+			free(gf->name);
+			gf->name = xstrdup(p2);
+		}
+		free(e);
+	}
+}
+
+/* Read a config option for a generated filename */
+static int gen_file_conf(struct gen_files *gf, int assgn, const char *parm, const char *arg)
+{
+
+	int l = strlen(gf->base);
+	if (assgn &&
+	    strncmp(parm, gf->base, l) == 0 &&
+	    strcmp(parm+l, "file") == 0 &&
+	    !gf->name) {
+		gf->name = xstrdup(arg);
+		return(0);
+	}
+	return(1);
+}
+
+/* Check we have a name for a generated file */
+static int gen_file_check(struct gen_files *gf, GLOB_LIST *g,
+			  char *base_dir, char *version)
+{
+	char tmp[PATH_MAX];
+	int ret = 0;
+	if (!gf->name) {
+		/*
+		 * Specification: config file / no xxxfile parameter
+		 * The default value for generated filename xxx is:
+		 *
+		 * xxxfile=/lib/modules/`uname -r`/modules.xxx
+		 *
+		 * If the config file exists but lacks an xxxfile
+		 * specification, the default value is used since
+		 * the system can't work without one.
+		 */
+		snprintf(tmp, sizeof(tmp), "%s/lib/modules/%s/modules.%s",
+			base_dir, version, gf->base);
+		gf->name = xstrdup(tmp);
+	} else { /* xxxfile defined in modules.conf */
+		/*
+		 * If we have a xxxfile definition in the configuration file
+		 * we must resolve any shell meta-chars in its value.
+		 */
+		if (meta_expand(gf->name, g, base_dir, version, ME_ALL))
+			ret = -1;
+		else if (!g->pathv || g->pathv[0] == NULL)
+			ret = -1;
+		else {
+			free(gf->name);
+			gf->name = xstrdup(g->pathv[0]);
+		}
+	}
+	return(ret);
+}
+
+/*
+ *	Read the configuration file.
+ *	If parameter "all" == 0 then ignore everything except path info
+ *	Return -1 if any error.
+ *	Error messages generated.
+ */
+static int do_read(int all, char *force_ver, char *base_dir, char *conf_file, int depth)
+{
+	#define MAX_LEVEL 20
+	FILE *fin;
+	GLOB_LIST g;
+	int i;
+	int assgn;
+	int drop_default_paths = 1;
+	int lineno = 0;
+	int ret = 0;
+	int state[MAX_LEVEL + 1]; /* nested "if" */
+	int level = 0;
+	int sizebuf;
+	char *buf = NULL;
+	char tmpline[PATH_MAX];
+	char **pathp;
+	char *envpath;
+	char *version;
+	char *type;
+	char **glb;
+	char old_name[] = "/etc/conf.modules";
+	int conf_file_specified = 0;
+
+	/*
+	 * The configuration file is optional.
+	 * No error is printed if it is missing.
+	 * If it is missing the following content is assumed.
+	 *
+	 * path[boot]=/lib/modules/boot
+	 *
+	 * path[toplevel]=/lib/modules/`uname -r`
+	 *
+	 * path[toplevel]=/lib/modules/`kernelversion`
+	 *   (where kernelversion gives the major kernel version: "2.0", "2.2"...)
+	 *
+	 * path[toplevel]=/lib/modules/default
+	 *
+	 * path[kernel]=/lib/modules/kernel
+	 * path[fs]=/lib/modules/fs
+	 * path[net]=/lib/modules/net
+	 * path[scsi]=/lib/modules/scsi
+	 * path[block]=/lib/modules/block
+	 * path[cdrom]=/lib/modules/cdrom
+	 * path[ipv4]=/lib/modules/ipv4
+	 * path[ipv6]=/lib/modules/ipv6
+	 * path[sound]=/lib/modules/sound
+	 * path[fc4]=/lib/modules/fc4
+	 * path[video]=/lib/modules/video
+	 * path[misc]=/lib/modules/misc
+	 * path[pcmcia]=/lib/modules/pcmcia
+	 * path[atm]=/lib/modules/atm
+	 * path[usb]=/lib/modules/usb
+	 * path[ide]=/lib/modules/ide
+	 * path[ieee1394]=/lib/modules/ieee1394
+	 * path[mtd]=/lib/modules/mtd
+	 *
+	 * The idea is that modprobe will look first if the
+	 * modules are compiled for the current release of the kernel.
+	 * If not found, it will look for modules that fit for the
+	 * general kernelversion (2.0, 2.2 and so on).
+	 * If still not found, it will look into the default release.
+	 * And if still not found, it will look in the other directories.
+	 *
+	 * The strategy should be like this:
+	 * When you install a new linux kernel, the modules should go
+	 * into a directory related to the release (version) of the kernel.
+	 * Then you can do a symlink "default" to this directory.
+	 *
+	 * Each time you compile a new kernel, the make modules_install
+	 * will create a new directory, but it won't change thee default.
+	 *
+	 * When you get a module unrelated to the kernel distribution
+	 * you can place it in one of the last three directory types.
+	 *
+	 * This is the default strategy. Of course you can overide
+	 * this in /etc/modules.conf.
+	 *
+	 * 2.3.15 added a new file tree walk algorithm which made it possible to
+	 * point at a top level directory and get the same behaviour as earlier
+	 * versions of modutils.  2.3.16 takes this one stage further, it
+	 * removes all the individual directory names from most of the scans,
+	 * only pointing at the top level directory.  The only exception is the
+	 * last ditch scan, scanning all of /lib/modules would be a bad idea(TM)
+	 * so the last ditch scan still runs individual directory names under
+	 * /lib/modules.
+	 *
+	 * Additional syntax:
+	 *
+	 * [add] above module module1 ...
+	 *	Specify additional modules to pull in on top of a module
+	 *
+	 * [add] below module module1 ...
+	 *	Specify additional modules needed to be able to load a module
+	 *
+	 * [add] prune filename ...
+	 *
+	 * [add] probe name module1 ...
+	 *	When "name" is requested, modprobe tries to install each
+	 *	module in the list until it succeeds.
+	 *
+	 * [add] probeall name module1 ...
+	 *	When "name" is requested, modprobe tries to install all
+	 *	modules in the list.
+	 *	If any module is installed, the command has succeeded.
+	 *
+	 * [add] options module option_list
+	 *
+	 * For all of the above, the optional "add" prefix is used to
+	 * add to a list instead of replacing the contents.
+	 *
+	 * include FILE_TO_INCLUDE
+	 *	This does what you expect. No limitation on include levels.
+	 *
+	 * persistdir=persist_directory
+	 *	Name the directory to save persistent data from modules.
+	 *
+	 * In the following WORD is a sequence if non-white characters.
+	 * If ' " or ` is found in the string, all characters up to the
+	 * matching ' " or ` will also be included, even whitespace.
+	 * Every WORD will then be expanded w.r.t. meta-characters.
+	 * If the expanded result gives more than one word, then only
+	 * the first word of the result will be used.
+	 *
+	 *
+	 * define CODE WORD
+	 *		Do a putenv("CODE=WORD")
+	 *
+	 * EXPRESSION below can be:
+	 *	WORD compare_op WORD
+	 *		where compare_op is one of == != < <= >= >
+	 *		The string values of the WORDs are compared
+	 * or
+	 *	-n WORD compare_op WORD
+	 *		where compare_op is one of == != < <= >= >
+	 *		The numeric values of the WORDs are compared
+	 * or
+	 *	WORD
+	 *		if the expansion of WORD fails, or if the
+	 *		expansion is "0" (zero), "false" or "" (empty)
+	 *		then the expansion has the value FALSE.
+	 *		Otherwise the expansion has the value TRUE
+	 * or
+	 *	-f FILENAME
+	 *		Test if the file FILENAME exists
+	 * or
+	 *	-k
+	 *		Test if "autoclean" (i.e. called from the kernel)
+	 * or
+	 *	! EXPRESSION
+	 *		A negated expression is also an expression
+	 *
+	 * if EXPRESSION
+	 *	any config line
+	 *	...
+	 * elseif EXPRESSION
+	 *	any config line
+	 *	...
+	 * else
+	 *	any config line
+	 *	...
+	 * endif
+	 *
+	 * The else and elseif keywords are optional.
+	 * "if"-statements nest up to 20 levels.
+	 */
+
+	state[0] = 1;
+
+	if (force_ver)
+		version = force_ver;
+	else
+		version = uts_info.release;
+
+	config_version = xstrdup(version);
+
+	/* Only read the default entries on the first file */
+	if (depth == 0) {
+		maxpath = 100;
+		modpath = (struct PATH_TYPE *)xmalloc(maxpath * sizeof(struct PATH_TYPE));
+		nmodpath = 0;
+
+		maxexecs = 10;
+		execs = (struct EXEC_TYPE *)xmalloc(maxexecs * sizeof(struct EXEC_TYPE));
+		nexecs = 0;
+
+		/*
+		 * Build predef options
+		 */
+		if (all && optlist[0])
+			n_opt_list = build_list(optlist, &opt_list, version, 1);
+
+		/*
+		 * Build predef above
+		 */
+		if (all && above[0])
+			n_abovelist = build_list(above, &abovelist, version, 0);
+
+		/*
+		 * Build predef below
+		 */
+		if (all && below[0])
+			n_belowlist = build_list(below, &belowlist, version, 0);
+
+		/*
+		 * Build predef prune list
+		 */
+		if (prune[0])
+			n_prunelist = build_list(prune, &prunelist, version, 0);
+
+		/*
+		 * Build predef aliases
+		 */
+		if (all && aliaslist[0])
+			n_aliases = build_list(aliaslist, &aliases, version, 0);
+
+		/* Order and priority is now: (MODPATH + modules.conf) || (predefs + modules.conf) */
+		if ((envpath = getenv("MODPATH")) != NULL && !safemode) {
+			size_t len;
+			char *p;
+			char *path;
+
+			/* Make a copy so's we can mung it with strtok.  */
+			len = strlen(envpath) + 1;
+			p = alloca(len);
+			memcpy(p, envpath, len);
+			path = alloca(PATH_MAX);
+
+			for (p = strtok(p, ":"); p != NULL; p = strtok(NULL, ":")) {
+				len = snprintf(path, PATH_MAX, p, version);
+				modpath[nmodpath].path = xstrdup(path);
+				if ((type = strrchr(path, '/')) != NULL)
+					type += 1;
+				else
+					type = "misc";
+				modpath[nmodpath].type = xstrdup(type);
+				if (++nmodpath >= maxpath) {
+					maxpath += 100;
+					modpath = (struct PATH_TYPE *)xrealloc(modpath,
+						maxpath * sizeof(struct PATH_TYPE));
+				}
+
+			}
+		} else {
+			/*
+			 * Build the default "path[type]" configuration
+			 */
+			int n;
+			char *k;
+
+			/* The first entry in the path list */
+			modpath[nmodpath].type = xstrdup("boot");
+			snprintf(tmpline, sizeof(tmpline), "%s/lib/modules/boot", base_dir);
+			modpath[nmodpath].path = xstrdup(tmpline);
+			++nmodpath;
+
+			/* The second entry in the path list, `uname -r` */
+			modpath[nmodpath].type = xstrdup("toplevel");
+			snprintf(tmpline, sizeof(tmpline), "%s/lib/modules/%s", base_dir, version);
+			modpath[nmodpath].path = xstrdup(tmpline);
+			++nmodpath;
+
+			/* The third entry in the path list, `kernelversion` */
+			modpath[nmodpath].type = xstrdup("toplevel");
+			for (n = 0, k = version; *k; ++k) {
+				if (*k == '.' && ++n == 2)
+					break;
+			}
+			snprintf(tmpline, sizeof(tmpline), "%s/lib/modules/%.*s", base_dir,
+				(/* typecast for Alpha */ int)(k - version), version);
+			modpath[nmodpath].path = xstrdup(tmpline);
+			++nmodpath;
+
+			/* The rest of the entries in the path list */
+			for (pathp = tbpath; *pathp; ++pathp) {
+				char **type;
+
+				for (type = tbtype; *type; ++type) {
+					char path[PATH_MAX];
+
+					snprintf(path, sizeof(path), "%s%s/%s", base_dir, *pathp, *type);
+					if (meta_expand(path, &g, NULL, version, ME_ALL)) {
+						ret = -1;
+						goto out;
+					}
+
+					for (glb = g.pathv; glb && *glb; ++glb) {
+						modpath[nmodpath].type = xstrdup(*type);
+						modpath[nmodpath].path = *glb;
+						if (++nmodpath >= maxpath) {
+							maxpath += 100;
+							modpath = (struct PATH_TYPE *)xrealloc(modpath,
+								maxpath * sizeof(struct PATH_TYPE));
+						}
+					}
+				}
+			}
+		}
+
+		/* Environment overrides for testing only, undocumented */
+		for (i = 0; i < gen_file_count; ++i)
+			gen_file_env(gen_file+i);
+
+	}	/* End of depth == 0 */
+
+	if (conf_file ||
+	    ((conf_file = getenv("MODULECONFIG")) != NULL && *conf_file && !safemode)) {
+		if (!(fin = fopen(conf_file, "r"))) {
+			error("Can't open %s", conf_file);
+			ret = -1;
+			goto out;
+		}
+		conf_file_specified = 1;
+	} else {
+		if (!(fin = fopen((conf_file = ETC_MODULES_CONF), "r"))) {
+			/* Fall back to non-standard name */
+			if ((fin = fopen((conf_file = old_name), "r"))) {
+				fprintf(stderr,
+					"Warning: modutils is reading from %s because\n"
+					"         %s does not exist.  The use of %s is\n"
+					"         deprecated, please rename %s to %s\n"
+					"         as soon as possible.  Command\n"
+					"         mv %s %s\n",
+					old_name, ETC_MODULES_CONF,
+					old_name, old_name, ETC_MODULES_CONF,
+					old_name, ETC_MODULES_CONF);
+			}
+			/* So what... use the default configuration */
+		}
+	}
+
+	if (fin) {
+		struct stat statbuf1, statbuf2;
+		if (fstat(fileno(fin), &statbuf1) == 0)
+			config_mtime = statbuf1.st_mtime;
+		config_file = xstrdup(conf_file);	/* Save name actually used */
+		if (!conf_file_specified &&
+		    stat(ETC_MODULES_CONF, &statbuf1) == 0 &&
+		    stat(old_name, &statbuf2) == 0) {
+			/* Both /etc files exist */
+			if (statbuf1.st_dev == statbuf2.st_dev &&
+			    statbuf1.st_ino == statbuf2.st_ino) {
+				if (lstat(ETC_MODULES_CONF, &statbuf1) == 0 &&
+				    S_ISLNK(statbuf1.st_mode))
+					fprintf(stderr,
+						"Warning: You do not need a link from %s to\n"
+						"         %s.  The use of %s is deprecated,\n"
+						"         please remove %s and rename %s\n"
+						"         to %s as soon as possible.  Commands.\n"
+						"           rm %s\n"
+						"           mv %s %s\n",
+						ETC_MODULES_CONF, old_name,
+						old_name, ETC_MODULES_CONF, old_name, ETC_MODULES_CONF,
+						ETC_MODULES_CONF,
+						old_name, ETC_MODULES_CONF);
+				else {
+#ifndef NO_WARN_ON_OLD_LINK
+					fprintf(stderr,
+						"Warning: You do not need a link from %s to\n"
+						"         %s.  The use of %s is deprecated,\n"
+						"         please remove %s as soon as possible.  Command\n"
+						"           rm %s\n",
+						old_name, ETC_MODULES_CONF,
+						old_name, old_name,
+						old_name);
+#endif
+				}
+			}
+			else
+				fprintf(stderr,
+					"Warning: modutils is reading from %s and\n"
+					"         ignoring %s.  The use of %s is deprecated,\n"
+					"         please remove %s as soon as possible.  Command\n"
+					"           rm %s\n",
+					ETC_MODULES_CONF, old_name,
+					old_name, old_name,
+					old_name);
+		}
+	}
+
+	/*
+	 * Finally, decode the file
+	 */
+	while (fin && fgets_strip(&buf, &sizebuf, fin, &lineno) != NULL) {
+		char *arg2;
+		char *parm = buf;
+		char *arg;
+		int one_err = 0;
+		int adding;
+
+		while (isspace(*parm))
+			parm++;
+
+		if (strncmp(parm, "add", 3) == 0) {
+			adding = 1;
+			parm += 3;
+			while (isspace(*parm))
+				parm++;
+		} else
+			adding = 0;
+
+		arg = parm;
+
+		if (*parm == '\0')
+			continue;
+
+		one_err = 1;
+
+		while (*arg > ' ' && *arg != '=')
+			arg++;
+
+		if (*arg == '=')
+			assgn = 1;
+		else
+			assgn = 0;
+		*arg++ = '\0';
+		while (isspace(*arg))
+			arg++;
+
+		/*
+		 * endif
+		 */
+		if (!assgn && strcmp(parm, "endif") == 0) {
+			if (level > 0)
+				--level;
+			else {
+				error("unmatched endif in line %d", lineno);
+				ret = -1;
+				goto out;
+			}
+			continue;
+		}
+
+		/*
+		 * else
+		 */
+		if (!assgn && strcmp(parm, "else") == 0) {
+			if (level <= 0) {
+				error("else without if in line %d", lineno);
+				ret = -1;
+				goto out;
+			}
+			state[level] = !state[level];
+			continue;
+		}
+
+		/*
+		 * elseif
+		 */
+		if (!assgn && strcmp(parm, "elseif") == 0) {
+			if (level <= 0) {
+				error("elseif without if in line %d", lineno);
+				ret = -1;
+				goto out;
+			}
+			if (state[level] != 0) {
+				/*
+				 * We have already found a TRUE
+				 * if statement in this "chain".
+				 * That's what "2" means.
+				 */
+				state[level] = 2;
+				continue;
+			}
+			/* else: No TRUE if has been found, cheat */
+			/*
+			 * The "if" handling increments level,
+			 * but this is the _same_ level as before.
+			 * So, compensate for it.
+			 */
+			--level;
+			parm = "if";
+			/* Fallthru to "if" */
+		}
+
+		/*
+		 * if
+		 */
+		if (strcmp(parm, "if") == 0) {
+			char *cmp;
+			int not = 0;
+			int numeric = 0;
+
+			if (level >= MAX_LEVEL) {
+				error("Too many nested if's in line %d\n", lineno);
+				ret = -1;
+				goto out;
+			}
+			state[++level] = 0; /* default false */
+
+			if (*arg == '!') {
+				not = 1;
+				arg = next_word(arg);
+			}
+
+			if (strncmp(arg, "-k", 2) == 0) {
+				state[level] = flag_autoclean;
+				continue;
+			}
+
+			if (strncmp(arg, "-f", 2) == 0) {
+				char *file = next_word(arg);
+				meta_expand(file, &g, NULL, version, ME_ALL);
+				if (access(g.pathc ? g.pathv[0] : file, R_OK) == 0)
+					state[level] = !not;
+				else
+					state[level] = not;
+				continue;
+			}
+
+			if (strncmp(arg, "-n", 2) == 0) {
+				numeric = 1;
+				arg = next_word(arg);
+			}
+
+
+			cmp = next_word(arg);
+			if (*cmp) {
+				GLOB_LIST g2;
+				long n1 = 0;
+				long n2 = 0;
+				char *w1 = "";
+				char *w2 = "";
+
+				arg2 = next_word(cmp);
+
+				meta_expand(arg, &g, NULL, version, ME_ALL);
+				if (g.pathc && g.pathv[0])
+					w1 = g.pathv[0];
+
+				meta_expand(arg2, &g2, NULL, version, ME_ALL);
+				if (g2.pathc && g2.pathv[0])
+					w2 = g2.pathv[0];
+
+				if (numeric) {
+					n1 = strtol(w1, NULL, 0);
+					n2 = strtol(w2, NULL, 0);
+				}
+
+				if (strcmp(cmp, "==") == 0 ||
+				    strcmp(cmp, "=") == 0) {
+					if (numeric)
+					    state[level] = (n1 == n2);
+					else
+					    state[level] = strcmp(w1, w2) == 0;
+				} else if (strcmp(cmp, "!=") == 0) {
+					if (numeric)
+					    state[level] = (n1 != n2);
+					else
+					    state[level] = strcmp(w1, w2) != 0;
+				} else if (strcmp(cmp, ">=") == 0) {
+					if (numeric)
+					    state[level] = (n1 >= n2);
+					else
+					    state[level] = strcmp(w1, w2) >= 0;
+				} else if (strcmp(cmp, "<=") == 0) {
+					if (numeric)
+					    state[level] = (n1 <= n2);
+					else
+					    state[level] = strcmp(w1, w2) <= 0;
+				} else if (strcmp(cmp, ">") == 0) {
+					if (numeric)
+					    state[level] = (n1 > n2);
+					else
+					    state[level] = strcmp(w1, w2) > 0;
+				} else if (strcmp(cmp, "<") == 0) {
+					if (numeric)
+					    state[level] = (n1 < n2);
+					else
+					    state[level] = strcmp(w1, w2) < 0;
+				}
+			} else { /* Check defined value, if any */
+				/* undef or defined as
+				 *	"" or "0" or "false" => false
+				 *  defined => true
+				 */
+				if (!meta_expand(arg, &g, NULL, version, ME_ALL) &&
+				    g.pathc > 0 &&
+				    strcmp(g.pathv[0], "0") != 0 &&
+				    strcmp(g.pathv[0], "false") != 0 &&
+				    strlen(g.pathv[0]) != 0)
+					state[level] = 1; /* true */
+			}
+			if (not)
+				state[level] = !state[level];
+
+			continue;
+		}
+
+		/*
+		 * Should we bother?
+		 */
+		if (state[level] != 1)
+			continue;
+
+		/*
+		 * define
+		 */
+		if (!assgn && strcmp(parm, "define") == 0) {
+			char env[PATH_MAX];
+
+			arg2 = next_word(arg);
+			meta_expand(arg2, &g, NULL, version, ME_ALL);
+			snprintf(env, sizeof(env), "%s=%s", arg, (g.pathc ? g.pathv[0] : ""));
+			putenv(xstrdup(env));
+			one_err = 0;
+		}
+
+		/*
+		 * include
+		 */
+		if (!assgn && strcmp(parm, "include") == 0) {
+			int inc_idx = 0;
+
+			while (*arg) {
+				arg2=next_word(arg);
+				meta_expand(arg, &g, NULL, version, ME_ALL);
+
+				if (g.pathc>0) {
+					for ( ; inc_idx<g.pathc; inc_idx++) {
+						if (!do_read(all, version, base_dir, g.pathv[inc_idx], depth+1))
+							one_err = 0;
+						else
+							error("include %s failed\n", g.pathv[inc_idx]);
+					}
+				}
+				else {
+					if (!do_read(all, version, base_dir, g.pathc ? g.pathv[0] : arg, depth+1))
+						one_err = 0;
+					else
+						error("include %s failed\n", arg);
+				}
+
+				arg = arg2;
+			}
+		}
+
+		/*
+		 * above
+		 */
+		else if (all && !assgn && strcmp(parm, "above") == 0) {
+			decode_list(&n_abovelist, &abovelist, arg, adding, version, 0);
+			one_err = 0;
+		}
+
+		/*
+		 * below
+		 */
+		else if (all && !assgn && strcmp(parm, "below") == 0) {
+			decode_list(&n_belowlist, &belowlist, arg, adding, version, 0);
+			one_err = 0;
+		}
+
+		/*
+		 * prune
+		 */
+		else if (!assgn && strcmp(parm, "prune") == 0) {
+			decode_list(&n_prunelist, &prunelist, arg, adding, version, 0);
+			one_err = 0;
+		}
+
+		/*
+		 * probe
+		 */
+		else if (all && !assgn && strcmp(parm, "probe") == 0) {
+			decode_list(&n_probe_list, &probe_list, arg, adding, version, 0);
+			one_err = 0;
+		}
+
+		/*
+		 * probeall
+		 */
+		else if (all && !assgn && strcmp(parm, "probeall") == 0) {
+			decode_list(&n_probeall_list, &probeall_list, arg, adding, version, 0);
+			one_err = 0;
+		}
+
+		/*
+		 * options
+		 */
+		else if (all && !assgn && strcmp(parm, "options") == 0) {
+			decode_list(&n_opt_list, &opt_list, arg, adding, version, 1);
+			one_err = 0;
+		}
+
+		/*
+		 * alias
+		 */
+		else if (all && !assgn && strcmp(parm, "alias") == 0) {
+			/*
+			 * Replace any previous (default) definitions
+			 * for the same module
+			 */
+			decode_list(&n_aliases, &aliases, arg, 0, version, 0);
+			one_err = 0;
+		}
+
+		/*
+		 * Specification: /etc/modules.conf
+		 * The format of the commands in /etc/modules.conf are:
+		 *
+		 *	pre-install module command
+		 *	install module command
+		 *	post-install module command
+		 *	pre-remove module command
+		 *	remove module command
+		 *	post-remove module command
+		 *
+		 * The different words are separated by tabs or spaces.
+		 */
+		/*
+		 * pre-install
+		 */
+		else if (all && !assgn && (strcmp(parm, "pre-install") == 0)) {
+			decode_exec(arg, EXEC_PRE_INSTALL);
+			one_err = 0;
+		}
+
+		/*
+		 * install
+		 */
+		else if (all && !assgn && (strcmp(parm, "install") == 0)) {
+			decode_exec(arg, EXEC_INSTALL);
+			one_err = 0;
+		}
+
+		/*
+		 * post-install
+		 */
+		else if (all && !assgn && (strcmp(parm, "post-install") == 0)) {
+			decode_exec(arg, EXEC_POST_INSTALL);
+			one_err = 0;
+		}
+
+		/*
+		 * pre-remove
+		 */
+		else if (all && !assgn && (strcmp(parm, "pre-remove") == 0)) {
+			decode_exec(arg, EXEC_PRE_REMOVE);
+			one_err = 0;
+		}
+
+		/*
+		 * remove
+		 */
+		else if (all && !assgn && (strcmp(parm, "remove") == 0)) {
+			decode_exec(arg, EXEC_REMOVE);
+			one_err = 0;
+		}
+
+		/*
+		 * post-remove
+		 */
+		else if (all && !assgn && (strcmp(parm, "post-remove") == 0)) {
+			decode_exec(arg, EXEC_POST_REMOVE);
+			one_err = 0;
+		}
+
+		/*
+		 * insmod_opt=
+		 */
+		else if (assgn && (strcmp(parm, "insmod_opt") == 0)) {
+			insmod_opt = xstrdup(arg);
+			one_err = 0;
+		}
+
+		/*
+		 * keep
+		 */
+		else if (!assgn && (strcmp(parm, "keep") == 0)) {
+			drop_default_paths = 0;
+			one_err = 0;
+		}
+
+		/*
+		 * path...=
+		 */
+		else if (assgn && strncmp(parm, "path", 4) == 0) {
+			/*
+			 * Specification: config file / path parameter
+			 * The path parameter specifies a directory to
+			 * search for modules.
+			 * This parameter may be repeated multiple times.
+			 *
+			 * Note that the actual path may be defined using
+			 * wildcards and other shell meta-chars, such as "*?`".
+			 * For example:
+			 *      path[misc]=/lib/modules/1.1.5?/misc
+			 *
+			 * Optionally the path keyword carries a tag.
+			 * This tells us a little more about the purpose of
+			 * this directory and allows some automated operations.
+			 * A path is marked with a tag by adding the tag,
+			 * enclosed in square brackets, to the path keyword:
+			 * #
+			 * path[boot]=/lib/modules/boot
+			 * #
+			 * This case identifies the path a of directory
+			 * holding modules loadable a boot time.
+			 */
+
+			if (drop_default_paths) {
+				int n;
+
+				/*
+				 * Specification: config file / path / default
+				 *
+				 * Whenever there is a path[] specification
+				 * in the config file, all the default
+				 * path are reset.
+				 *
+				 * If one instead wants to _add_ to the default
+				 * set of paths, one has to have the option
+				 *    keep
+				 * before the first path[]-specification line
+				 * in the configuration file.
+				 */
+				drop_default_paths = 0;
+				for (n = 0; n < nmodpath; n++) {
+					free(modpath[n].path);
+					free(modpath[n].type);
+				}
+				nmodpath = 0;
+			}
+
+			/*
+			 * Get (the optional) tag
+			 * If the tag is missing, the word "misc"
+			 * is assumed.
+			 */
+			type = "misc";
+
+			if (parm[4] == '[') {
+				char *pt_type = parm + 5;
+
+				while (*pt_type != '\0' && *pt_type != ']')
+					pt_type++;
+
+				if (*pt_type == ']' && pt_type[1] == '\0') {
+					*pt_type = '\0';
+					type = parm + 5;
+				} /* else CHECKME */
+			}
+
+			/*
+			 * Handle the actual path description
+			 */
+			if (meta_expand(arg, &g, base_dir, version, ME_ALL)) {
+				ret = -1;
+				goto out;
+			}
+			for (glb = g.pathv; glb && *glb; ++glb) {
+				modpath[nmodpath].type = xstrdup(type);
+				modpath[nmodpath].path = *glb;
+				if (++nmodpath >= maxpath) {
+					maxpath += 100;
+					modpath = (struct PATH_TYPE *)xrealloc(modpath,
+						maxpath * sizeof(struct PATH_TYPE));
+				}
+			}
+			one_err = 0;
+		}
+
+		/*
+		 * persistdir
+		 */
+		else if (assgn && strcmp(parm, "persistdir") == 0) {
+			meta_expand(arg, &g, NULL, version, ME_ALL);
+			persistdir = xstrdup(g.pathc ? g.pathv[0] : arg);
+			one_err = 0;
+		}
+
+		/* Names for generated files in config file */
+		for (i = 0; one_err && i < gen_file_count; ++i)
+			one_err = gen_file_conf(gen_file+i, assgn, parm, arg);
+
+		/*
+		 * any errors so far?
+		 */
+		if (all == 0)
+			one_err = 0;
+		else if (one_err) {
+			error("Invalid line %d in %s\n\t%s",
+				     lineno, conf_file, buf);
+			ret = -1;
+		}
+	}
+	if (fin)
+		fclose(fin);
+
+	if (level) {
+		error("missing endif at %s EOF", conf_file);
+		ret = -1;
+	}
+
+	if (ret)
+		goto out;
+	/* else */
+
+	if (depth == 0) {
+		/* Check we have names for generated files */
+		for (i = 0; !ret && i < gen_file_count; ++i)
+			ret = gen_file_check(gen_file+i, &g, base_dir, version);
+	}
+
+out:
+	return ret;
+}
+
+int config_read(int all, char *force_ver, char *base_dir, char *conf_file)
+{
+	int r;
+	if (modpath != NULL)
+		return 0; /* already initialized */
+
+	if (uname(&uts_info) < 0) {
+		error("Failed to find kernel name information");
+		return -1;
+	}
+
+	if (access(MODUTILS_MACROS, R_OK) == 0){
+		r = do_read(all, force_ver, base_dir, MODUTILS_MACROS, 0);
+		r = do_read(all, force_ver, "", conf_file, 1);
+	} else {
+		r = do_read(all, force_ver, base_dir, conf_file, 0);
+	} 
+
+	if (quick && !r && !need_update (force_ver, base_dir))
+		exit (0);
+
+	return r;
+}
+
+/****************************************************************************/
+/*
+ *	FIXME: Far too much global state.  KAO.
+ */
+static int found;
+static int favail;
+static int one_only;
+static int meta_expand_type;
+char **list;
+static const char *filter_by_file;
+static char *filter_by_dir;
+
+/*
+ *	Add a file name if it exist
+ */
+static int config_add(const char *file, const struct stat *sb)
+{
+	int i;
+	int npaths = 0;
+	char **paths = NULL;
+
+	if (meta_expand_type) {
+		GLOB_LIST g;
+		char **p;
+		char full[PATH_MAX];
+
+		snprintf(full, sizeof(full), "%s/%s", file, filter_by_file);
+
+		if (filter_by_dir && !strstr(full, filter_by_dir))
+			return 0;
+
+		if (meta_expand(full, &g, NULL, config_version, meta_expand_type))
+			return 1;
+		for (p = g.pathv; p && *p; ++p) {
+			paths = (char **)xrealloc(paths,
+					(npaths + 1) * sizeof(char *));
+			paths[npaths++] = *p;
+		}
+	} else { /* normal path match or match with "*" */
+		if (!S_ISREG(sb->st_mode))
+			return 0;
+
+		if (strcmp(filter_by_file, "*")) {
+			char *p;
+
+			if ((p = strrchr(file, '/')) == NULL)
+				p = (char *)file;
+			else
+				p += 1;
+
+			if (strcmp(p, filter_by_file))
+				return 0;
+		}
+		if (filter_by_dir && !strstr(file, filter_by_dir))
+			return 0;
+		paths = (char **)xmalloc(sizeof(char **));
+		*paths = xstrdup(file);
+		npaths = 1;
+	}
+
+	for (i = 0; i < npaths; ++i) {
+		struct stat sbuf;
+
+		if (S_ISDIR(sb->st_mode)) {
+			if (stat(paths[i], &sbuf) == 0)
+				sb = &sbuf;
+		}
+		if (S_ISREG(sb->st_mode) && sb->st_mode & S_IRUSR) {
+			int j;
+			char **this;
+
+			if (!root_check_off) {
+				if (sb->st_uid != 0) {
+					error("%s is not owned by root", paths[i]);
+					continue;
+				}
+			}
+
+			/* avoid duplicates */
+			for (j = 0, this = list; j < found; ++j, ++this) {
+				if (strcmp(*this, paths[i]) == 0) {
+					free(paths[i]);
+					goto next;
+				}
+			}
+
+			list[found] = paths[i];
+			if (++found >= favail)
+				list = (char **)xrealloc(list,
+				     (favail += 100) * sizeof(char *));
+
+			if (one_only) {
+				for (j = i + 1; j < npaths; ++j)
+					free(paths[j]);
+				free(paths);
+				return 1; /* finish xftw */
+			}
+		}
+	    next: ;
+	}
+
+	if (npaths > 0)
+		free(paths);
+
+	return 0;
+}
+
+/*
+ * Find modules matching the name "match" in directory of type "type"
+ * (type == NULL matches all)
+ *
+ * Return a pointer to the list of modules found (or NULL if error).
+ * Update the counter (sent as parameter).
+ */
+GLOB_LIST *config_lstmod(const char *match, const char *type, int first_only)
+{
+	/*
+	 * Note:
+	 * There are _no_ wildcards remaining in the path descriptions!
+	 */
+	struct stat sb;
+	int i;
+	int ret = 0;
+	char *path = NULL;
+	char this[PATH_MAX];
+
+	if (!match)
+		match = "*";
+	one_only = first_only;
+	found = 0;
+	filter_by_file = match;
+	filter_by_dir = NULL;
+	if (type) {
+		char tmpdir[PATH_MAX];
+		snprintf(tmpdir, sizeof(tmpdir), "/%s/", type);
+		filter_by_dir = xstrdup(tmpdir);
+	}
+	/* In safe mode, the module name is always handled as is, without meta
+	 * expansion.  It might have come from an end user via kmod and must
+	 * not be trusted.  Even in unsafe mode, only apply globbing to the
+	 * module name, not command expansion.  We trust config file input so
+	 * applying command expansion is safe, we do not trust command line input.
+	 * This assumes that the only time the user can specify -C config file
+	 * is when they run under their own authority.  In particular all
+	 * mechanisms that call modprobe as root on behalf of the user must
+	 * run in safe mode, without letting the user supply a config filename.
+	 */
+	meta_expand_type = 0;
+	if (strpbrk(match, SHELL_META) && strcmp(match, "*") && !safemode)
+		meta_expand_type = ME_GLOB|ME_BUILTIN_COMMAND;
+
+	list = (char **)xmalloc((favail = 100) * sizeof(char *));
+
+	for (i = 0; i < nmodpath; i++) {
+		path = modpath[i].path;
+		/* Special case: insmod: handle single, non-wildcard match */
+		if (first_only && strpbrk(match, SHELL_META) == NULL) {
+			/* Fix for "2.1.121 syntax */
+			snprintf(this, sizeof(this), "%s/%s/%s", path,
+						  modpath[i].type, match);
+			if (stat(this, &sb) == 0 &&
+			    config_add(this, &sb))
+				break;
+			/* End fix for "2.1.121 syntax */
+
+			snprintf(this, sizeof(this), "%s/%s", path, match);
+			if (stat(this, &sb) == 0 &&
+			    config_add(this, &sb))
+				break;
+		}
+
+		/* Start looking */
+		if ((ret = xftw(path, config_add))) {
+			break;
+		}
+	}
+	if (ret >= 0) {
+		GLOB_LIST *g = (GLOB_LIST *)xmalloc(sizeof(GLOB_LIST));
+		g->pathc = found;
+		g->pathv = list;
+		free(filter_by_dir);
+		return g;
+	}
+	free(list);
+	free(filter_by_dir);
+	return NULL;
+}
+
+/* Given a bare module name, poke through the module path to find the file.  */
+char *search_module_path(const char *base)
+{
+	GLOB_LIST *g;
+
+	if (config_read(0, NULL, "", NULL) < 0)
+		return NULL;
+	/* else */
+	g = config_lstmod(base, NULL, 1);
+	if (g == NULL || g->pathc == 0) {
+		char base_o[PATH_MAX];
+
+		snprintf(base_o, sizeof(base_o), "%s.o", base);
+		g = config_lstmod(base_o, NULL, 1);
+#ifdef CONFIG_USE_ZLIB
+		if (g == NULL || g->pathc == 0) {
+			snprintf(base_o, sizeof(base_o), "%s.o.gz", base);
+			g = config_lstmod(base_o, NULL, 1);
+		}
+#endif
+	}
+	if (g == NULL || g->pathc == 0)
+		return NULL;
+	/* else */
+	return g->pathv[0];
+}
diff -urN linux-2.4.37.11-orig//modutils/config.h linux-2.4.37.11-rescue//modutils/config.h
--- linux-2.4.37.11-orig//modutils/config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/config.h	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,108 @@
+/*
+ * Configuration file management
+ *
+ * Copyright 1994, 1995, 1996, 1997:
+ *	Jacques Gelinas <jack@solucorp.qc.ca>
+ *	Björn Ekwall <bj0rn@blox.se> February, March 1999
+ *
+ * This file is part of the Linux modutils.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CONFIG_H
+#define _CONFIG_H
+
+#include <stdio.h>
+#include <sys/utsname.h>
+
+#define MODUTILS_MACROS        "/lib/modutils/macros"
+#define ETC_MODULES_CONF	"/etc/modules.conf"
+
+#define EXEC_PRE_INSTALL 0
+#define EXEC_POST_INSTALL 1
+#define EXEC_PRE_REMOVE 2
+#define EXEC_POST_REMOVE 3
+#define EXEC_INSTALL 4
+#define EXEC_REMOVE 5
+
+struct PATH_TYPE {
+	char *type;
+	char *path;
+};
+
+struct EXEC_TYPE {
+	int when;
+	char *module;
+	char *cmd;
+};
+
+typedef struct {
+	char *name;
+	GLOB_LIST *opts;
+	int autoclean;
+} OPT_LIST;
+
+/* config.c */
+extern int flag_autoclean;
+extern struct utsname uts_info;
+extern char *aliaslist[];
+extern struct PATH_TYPE *modpath;
+extern int nmodpath;
+extern struct EXEC_TYPE *execs;
+extern int nexecs;
+extern char *insmod_opt;
+extern char *config_file;
+extern char *optlist[];
+extern char *prune[];
+extern OPT_LIST *opt_list;
+extern OPT_LIST *abovelist;
+extern OPT_LIST *belowlist;
+extern OPT_LIST *prunelist;
+extern OPT_LIST *probe_list;
+extern OPT_LIST *probeall_list;
+extern OPT_LIST *aliases;
+extern time_t config_mtime;
+extern int root_check_off;	/* Check modules are owned by root? */
+
+/* Information about generated files */
+struct gen_files {
+	char *base;		/* xxx in /lib/modules/`uname -r`/modules.xxx */
+	char *name;             /* name actually used */
+	time_t mtime;
+};
+
+extern struct gen_files gen_file[];
+extern const int gen_file_count;
+/* The enum order must match the gen_file initialization order in config.c */
+enum gen_file_enum {
+	GEN_GENERIC_STRINGFILE,
+	GEN_PCIMAPFILE,
+	GEN_ISAPNPMAPFILE,
+	GEN_USBMAPFILE,
+	GEN_PARPORTMAPFILE,
+	GEN_IEEE1394MAPFILE,
+	GEN_PNPBIOSMAPFILE,
+	GEN_DEPFILE,
+};
+
+extern char *persistdir;
+
+char *fgets_strip(char **buf, int *sizebuf, FILE * fin, int *lineno);
+int config_read(int all, char *force_ver, char *base_dir, char *conf_file);
+GLOB_LIST *config_lstmod(const char *match, const char *type, int first_only);
+char *search_module_path(const char *base);
+
+#endif /* _CONFIG_H */
diff -urN linux-2.4.37.11-orig//modutils/elf_i386.h linux-2.4.37.11-rescue//modutils/elf_i386.h
--- linux-2.4.37.11-orig//modutils/elf_i386.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/elf_i386.h	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,9 @@
+/* Machine-specific elf macros for i386 et al.  */
+
+#define ELFCLASSM	ELFCLASS32
+#define ELFDATAM	ELFDATA2LSB
+
+#define MATCH_MACHINE(x)  (x == EM_386)
+
+#define SHT_RELM	SHT_REL
+#define Elf32_RelM	Elf32_Rel
diff -urN linux-2.4.37.11-orig//modutils/elf_x86_64.h linux-2.4.37.11-rescue//modutils/elf_x86_64.h
--- linux-2.4.37.11-orig//modutils/elf_x86_64.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/elf_x86_64.h	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,11 @@
+/* Machine-specific elf macros for x86_64.  */
+
+#define ELFCLASSM	ELFCLASS64
+#define ELFDATAM	ELFDATA2LSB
+
+#define MATCH_MACHINE(x)  (x == EM_X86_64)
+
+#define SHT_RELM	SHT_RELA
+#define Elf64_RelM	Elf64_Rela
+
+#define arch_module_base(m) ((ElfW(Addr)) 0xffffffff00000000ull)
diff -urN linux-2.4.37.11-orig//modutils/genksyms.c linux-2.4.37.11-rescue//modutils/genksyms.c
--- linux-2.4.37.11-orig//modutils/genksyms.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/genksyms.c	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,601 @@
+/* Generate kernel symbol version hashes.
+   Copyright 1996, 1997 Linux International.
+
+   New implementation contributed by Richard Henderson <rth@tamu.edu>
+   Based on original work by Bjorn Ekwall <bj0rn@blox.se>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <assert.h>
+#include <stdarg.h>
+#include <getopt.h>
+
+#include "genksyms.h"
+#include "util.h"
+#include "version.h"
+
+/*----------------------------------------------------------------------*/
+
+#define HASH_BUCKETS  4099
+
+static struct symbol *symtab[HASH_BUCKETS];
+FILE *outfile, *debugfile;
+
+int cur_line = 1;
+char *cur_filename, *output_directory;
+
+int flag_debug, flag_dump_defs, flag_warnings;
+int checksum_version = 1, kernel_version = version(2,0,0);
+
+static int errors;
+static int nsyms;
+
+static struct symbol *expansion_trail;
+static const char *crc_prefix = "";
+
+static const char * const symbol_type_name[] = {
+  "normal", "typedef", "enum", "struct", "union"
+};
+
+/*----------------------------------------------------------------------*/
+
+static const unsigned int crctab32[] =
+{
+#include "crc32.tab"
+};
+
+static inline unsigned long
+partial_crc32_one(unsigned char c, unsigned long crc)
+{
+  return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
+}
+
+static inline unsigned long
+partial_crc32(const char *s, unsigned long crc)
+{
+  while (*s)
+    crc = partial_crc32_one(*s++, crc);
+  return crc;
+}
+
+static inline unsigned long
+crc32(const char *s)
+{
+  return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
+}
+
+
+/*----------------------------------------------------------------------*/
+
+static inline enum symbol_type
+map_to_ns(enum symbol_type t)
+{
+  if (t == SYM_TYPEDEF)
+    t = SYM_NORMAL;
+  else if (t == SYM_UNION)
+    t = SYM_STRUCT;
+  return t;
+}
+
+struct symbol *
+find_symbol(const char *name, enum symbol_type ns)
+{
+  unsigned long h = crc32(name) % HASH_BUCKETS;
+  struct symbol *sym;
+
+  for (sym = symtab[h]; sym ; sym = sym->hash_next)
+    if (map_to_ns(sym->type) == map_to_ns(ns) && strcmp(name, sym->name) == 0)
+      break;
+
+  return sym;
+}
+
+struct symbol *
+add_symbol(const char *name, enum symbol_type type, struct string_list *defn, int is_extern)
+{
+  unsigned long h = crc32(name) % HASH_BUCKETS;
+  struct symbol *sym;
+
+  for (sym = symtab[h]; sym ; sym = sym->hash_next)
+    if (map_to_ns(sym->type) == map_to_ns(type)
+	&& strcmp(name, sym->name) == 0)
+      {
+	if (!equal_list(sym->defn, defn))
+	  error_with_pos("redefinition of %s", name);
+	return sym;
+      }
+
+  sym = xmalloc(sizeof(*sym));
+  sym->name = name;
+  sym->type = type;
+  sym->defn = defn;
+  sym->expansion_trail = NULL;
+  sym->is_extern = is_extern;
+
+  sym->hash_next = symtab[h];
+  symtab[h] = sym;
+
+  if (flag_debug)
+    {
+      fprintf(debugfile, "Defn for %s %s == <", symbol_type_name[type],  name);
+      if (is_extern)
+        fputs("extern ", debugfile);
+      print_list(debugfile, defn);
+      fputs(">\n", debugfile);
+    }
+
+  ++nsyms;
+  return sym;
+}
+
+
+/*----------------------------------------------------------------------*/
+
+inline void
+free_node(struct string_list *node)
+{
+  free(node->string);
+  free(node);
+}
+
+void
+free_list(struct string_list *s, struct string_list *e)
+{
+  while (s != e)
+    {
+      struct string_list *next = s->next;
+      free_node(s);
+      s = next;
+    }
+}
+
+inline struct string_list *
+copy_node(struct string_list *node)
+{
+  struct string_list *newnode;
+
+  newnode = xmalloc(sizeof(*newnode));
+  newnode->string = xstrdup(node->string);
+  newnode->tag = node->tag;
+
+  return newnode;
+}
+
+struct string_list *
+copy_list(struct string_list *s, struct string_list *e)
+{
+  struct string_list *h, *p;
+
+  if (s == e)
+    return NULL;
+
+  p = h = copy_node(s);
+  while ((s = s->next) != e)
+    p = p->next = copy_node(s);
+  p->next = NULL;
+
+  return h;
+}
+
+int
+equal_list(struct string_list *a, struct string_list *b)
+{
+  while (a && b)
+    {
+      if (a->tag != b->tag || strcmp(a->string, b->string))
+	return 0;
+      a = a->next;
+      b = b->next;
+    }
+
+  return !a && !b;
+}
+
+static inline void
+print_node(FILE *f, struct string_list *list)
+{
+  switch (list->tag)
+    {
+    case SYM_STRUCT:
+      putc('s', f);
+      goto printit;
+    case SYM_UNION:
+      putc('u', f);
+      goto printit;
+    case SYM_ENUM:
+      putc('e', f);
+      goto printit;
+    case SYM_TYPEDEF:
+      putc('t', f);
+      goto printit;
+
+    printit:
+      putc('#', f);
+    case SYM_NORMAL:
+      fputs(list->string, f);
+      break;
+    }
+}
+
+void
+print_list(FILE *f, struct string_list *list)
+{
+  struct string_list **e, **b;
+  struct string_list *tmp, **tmp2;
+  int elem = 1;
+
+  if (list == NULL)
+    {
+      fputs("(nil)", f);
+      return;
+    }
+
+  tmp = list;
+  while((tmp = tmp->next) != NULL)
+	  elem++;
+
+  b = alloca(elem * sizeof(*e));
+  e = b + elem;
+  tmp2 = e - 1;
+
+  (*tmp2--) = list;
+  while((list = list->next) != NULL)
+	  *(tmp2--) = list;
+
+  while (b != e)
+    {
+      print_node(f, *b++);
+      putc(' ', f);
+    }
+}
+
+static unsigned long
+expand_and_crc_list(struct string_list *list, unsigned long crc)
+{
+  struct string_list **e, **b;
+  struct string_list *tmp, **tmp2;
+  int elem = 1;
+
+  if (!list)
+    return crc;
+
+  tmp = list;
+  while((tmp = tmp->next) != NULL)
+	  elem++;
+
+  b = alloca(elem * sizeof(*e));
+  e = b + elem;
+  tmp2 = e - 1;
+
+  *(tmp2--) = list;
+  while ((list = list->next) != NULL)
+    *(tmp2--) = list;
+
+  while (b != e)
+    {
+      struct string_list *cur;
+      struct symbol *subsym;
+
+      cur = *(b++);
+      switch (cur->tag)
+	{
+	case SYM_NORMAL:
+	  if (flag_dump_defs)
+	    fprintf(debugfile, "%s ", cur->string);
+	  crc = partial_crc32(cur->string, crc);
+	  crc = partial_crc32_one(' ', crc);
+	  break;
+
+	case SYM_TYPEDEF:
+	  subsym = find_symbol(cur->string, cur->tag);
+	  if (checksum_version == 1)
+	    crc = expand_and_crc_list(subsym->defn, crc);
+	  else if (subsym->expansion_trail)
+	    {
+	      if (flag_dump_defs)
+		fprintf(debugfile, "%s ", cur->string);
+	      crc = partial_crc32(cur->string, crc);
+	      crc = partial_crc32_one(' ', crc);
+	    }
+	  else
+	    {
+	      subsym->expansion_trail = expansion_trail;
+	      expansion_trail = subsym;
+	      crc = expand_and_crc_list(subsym->defn, crc);
+	    }
+	  break;
+
+	case SYM_STRUCT:
+	case SYM_UNION:
+	case SYM_ENUM:
+	  subsym = find_symbol(cur->string, cur->tag);
+	  if (!subsym)
+	    {
+	      struct string_list *n, *t = NULL;
+
+	      error_with_pos("expand undefined %s %s",
+			     symbol_type_name[cur->tag], cur->string);
+
+	      n = xmalloc(sizeof(*n));
+	      n->string = xstrdup(symbol_type_name[cur->tag]);
+	      n->tag = SYM_NORMAL;
+	      n->next = t;
+	      t = n;
+
+	      n = xmalloc(sizeof(*n));
+	      n->string = xstrdup(cur->string);
+	      n->tag = SYM_NORMAL;
+	      n->next = t;
+	      t = n;
+
+	      n = xmalloc(sizeof(*n));
+	      n->string = xstrdup("{ UNKNOWN }");
+	      n->tag = SYM_NORMAL;
+	      n->next = t;
+
+	      subsym = add_symbol(cur->string, cur->tag, n, 0);
+	    }
+	  if (subsym->expansion_trail)
+	    {
+	      if (flag_dump_defs)
+		{
+		  fprintf(debugfile, "%s %s ", symbol_type_name[cur->tag],
+			  cur->string);
+		}
+
+	      crc = partial_crc32(symbol_type_name[cur->tag], crc);
+	      crc = partial_crc32_one(' ', crc);
+	      crc = partial_crc32(cur->string, crc);
+	      crc = partial_crc32_one(' ', crc);
+	    }
+	  else
+	    {
+	      subsym->expansion_trail = expansion_trail;
+	      expansion_trail = subsym;
+	      crc = expand_and_crc_list(subsym->defn, crc);
+	    }
+	  break;
+	}
+    }
+
+  return crc;
+}
+
+void
+export_symbol(const char *name)
+{
+  struct symbol *sym;
+
+  sym = find_symbol(name, SYM_NORMAL);
+  if (!sym)
+    error_with_pos("export undefined symbol %s", name);
+  else
+    {
+      unsigned long crc;
+
+      if (flag_dump_defs)
+	fprintf(debugfile, "Export %s == <", name);
+
+      expansion_trail = (struct symbol *)-1L;
+
+      crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
+
+      sym = expansion_trail;
+      while (sym != (struct symbol *)-1L)
+	{
+	  struct symbol *n = sym->expansion_trail;
+	  sym->expansion_trail = 0;
+	  sym = n;
+	}
+
+      if (flag_dump_defs)
+	fputs(">\n", debugfile);
+
+      if (checksum_version > 1)
+	{
+	  fprintf(outfile, "#define __ver_%s\t%s%08lx\n", name,
+		  crc_prefix, crc);
+	  fprintf(outfile, "#define %s\t_set_ver(%s)\n", name, name);
+	}
+      else
+	{
+	  fprintf(outfile, "#define %s\t_set_ver(%s, %s%08lx)\n", name, name,
+		  crc_prefix, crc);
+	}
+    }
+}
+
+
+/*----------------------------------------------------------------------*/
+
+static int
+parse_kernel_version(char * p)
+{
+  int a, b, c;
+
+  a = strtoul(p, &p, 10);
+  if (*p != '.')
+    return -1;
+  b = strtoul(p+1, &p, 10);
+  if (*p != '.')
+    return -1;
+  c = strtoul(p+1, &p, 10);
+  if (*p != '\0')
+    return -1;
+
+  kernel_version = a << 16 | b << 8 | c;
+
+  return 0;
+}
+
+void
+error(const char *fmt, ...)
+{
+  va_list args;
+
+  if (flag_warnings)
+    {
+      va_start(args, fmt);
+      vfprintf(stderr, fmt, args);
+      va_end(args);
+      putc('\n', stderr);
+
+      errors++;
+    }
+}
+
+void
+error_with_pos(const char *fmt, ...)
+{
+  va_list args;
+
+  if (flag_warnings)
+    {
+      fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);
+
+      va_start(args, fmt);
+      vfprintf(stderr, fmt, args);
+      va_end(args);
+      putc('\n', stderr);
+
+      errors++;
+    }
+}
+
+
+void genksyms_usage(void)
+{
+	fputs("Usage:\n"
+	      "genksyms [-dDwqhV] [-k kernel_version] [-p prefix] > .../linux/module/*.ver\n"
+	      "\n"
+	      "  -d, --debug           Increment the debug level (repeatable)\n"
+	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
+	      "  -w, --warnings        Enable warnings\n"
+	      "  -q, --quiet           Disable warnings (default)\n"
+	      "  -h, --help            Print this message\n"
+	      "  -V, --version         Print the release version\n"
+	      "  -k ver\n"
+	      "       --kernel ver     Set the kernel version for which we are compiling\n"
+	      "  -p string\n"
+	      "       --prefix string  Set a mangling prefix for all symbols\n"
+	      , stderr);
+}
+
+int
+main(int argc, char **argv)
+{
+  int o;
+
+  struct option long_opts[] = {
+    {"debug", 0, 0, 'd'},
+    {"warnings", 0, 0, 'w'},
+    {"quiet", 0, 0, 'q'},
+    {"dump", 0, 0, 'D'},
+    {"kernel", 1, 0, 'k'},
+    {"prefix", 1, 0, 'p'},
+    {"version", 0, 0, 'V'},
+    {"help", 0, 0, 'h'},
+    {0, 0, 0, 0}
+  };
+
+  while ((o = getopt_long(argc, argv, "dwqVDk:p:",
+			  &long_opts[0], NULL)) != EOF)
+    switch (o)
+      {
+      case 'd':
+	flag_debug++;
+	break;
+      case 'w':
+	flag_warnings = 1;
+	break;
+      case 'q':
+	flag_warnings = 0;
+	break;
+      case 'V':
+	fputs("genksyms version " MODUTILS_VERSION "\n", stderr);
+	break;
+      case 'D':
+	flag_dump_defs = 1;
+	break;
+      case 'k':
+	if (parse_kernel_version(optarg)) {
+	    fprintf( stderr, "unrecognised kernel version : %s\n", optarg);
+	    return -1;
+	}
+	break;
+      case 'p':
+	crc_prefix = optarg;
+	break;
+      case 'h':
+	genksyms_usage();
+	return 0;
+      default:
+	genksyms_usage();
+	return 1;
+      }
+
+  if (kernel_version >= version(2,1,18))
+    {
+      if (optind != argc) {
+	  genksyms_usage();
+	  return 1;
+      }
+
+      /* For newer kernels, eliminate some irrelevant constructs.  */
+      checksum_version = 2;
+
+      outfile = stdout;
+    }
+  else
+    {
+      if (optind+1 != argc) {
+	  genksyms_usage();
+	  return 1;
+      }
+      output_directory = argv[optind];
+    }
+
+    {
+      extern int yydebug;
+      extern int yy_flex_debug;
+
+      yydebug = (flag_debug > 1);
+      yy_flex_debug = (flag_debug > 2);
+
+      debugfile = stderr;
+      /* setlinebuf(debugfile); */
+    }
+
+  yyparse();
+
+  if (checksum_version == 1)
+    {
+      fputs("#endif\n#endif\n", outfile);
+    }
+
+  if (flag_debug)
+    {
+      fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
+	      nsyms, HASH_BUCKETS, (double)nsyms / (double)HASH_BUCKETS);
+    }
+
+  return errors != 0;
+}
diff -urN linux-2.4.37.11-orig//modutils/genksyms.h linux-2.4.37.11-rescue//modutils/genksyms.h
--- linux-2.4.37.11-orig//modutils/genksyms.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/genksyms.h	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,86 @@
+/* Generate kernel symbol version hashes.
+   Copyright 1996, 1997 Linux International.
+
+   New implementation contributed by Richard Henderson <rth@tamu.edu>
+   Based on original work by Bjorn Ekwall <bj0rn@blox.se>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+#ifndef MODUTILS_GENKSYMS_H
+#define MODUTILS_GENKSYMS_H 1
+
+#include <stdio.h>
+
+enum symbol_type
+{
+  SYM_NORMAL, SYM_TYPEDEF, SYM_ENUM, SYM_STRUCT, SYM_UNION
+};
+
+struct string_list
+{
+  struct string_list *next;
+  enum symbol_type tag;
+  char *string;
+};
+
+struct symbol
+{
+  struct symbol *hash_next;
+  const char *name;
+  enum symbol_type type;
+  struct string_list *defn;
+  struct symbol *expansion_trail;
+  int is_extern;
+};
+
+typedef struct string_list **yystype;
+#define YYSTYPE yystype
+
+extern FILE *outfile, *debugfile;
+
+extern int cur_line;
+extern char *cur_filename, *output_directory;
+
+extern int flag_debug, flag_dump_defs, flag_warnings;
+extern int checksum_version, kernel_version;
+
+extern int want_brace_phrase, want_exp_phrase, discard_phrase_contents;
+extern struct string_list *current_list, *next_list;
+
+
+struct symbol *find_symbol(const char *name, enum symbol_type ns);
+struct symbol *add_symbol(const char *name, enum symbol_type type,
+			   struct string_list *defn, int is_extern);
+void export_symbol(const char *);
+
+struct string_list *reset_list(void);
+void free_list(struct string_list *s, struct string_list *e);
+void free_node(struct string_list *list);
+struct string_list *copy_node(struct string_list *);
+struct string_list *copy_list(struct string_list *s, struct string_list *e);
+int equal_list(struct string_list *a, struct string_list *b);
+void print_list(FILE *, struct string_list *list);
+
+int yylex(void);
+int yyparse(void);
+
+void error_with_pos(const char *, ...);
+
+#define version(a,b,c)  ((a << 16) | (b << 8) | (c))
+
+#endif /* genksyms.h */
diff -urN linux-2.4.37.11-orig//modutils/gzfiles.c linux-2.4.37.11-rescue//modutils/gzfiles.c
--- linux-2.4.37.11-orig//modutils/gzfiles.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/gzfiles.c	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,74 @@
+/*
+ * This simple library intends to make it transparent to read gzipped and/or
+ * standard files. This is simple enough to fit modutils' needs, but may be
+ * easily adapted to anyone's needs. It's completely free, do what you want
+ * with it .  - Willy Tarreau <willy@meta-x.org> - 2000/05/05 -
+ */
+
+#ifdef CONFIG_USE_ZLIB
+
+#include <stdio.h>
+#include <zlib.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+/* redefinition of gz_stream which isn't exported by zlib */
+typedef struct gz_stream {
+    z_stream stream;
+    int      z_err;   /* error code for last stream operation */
+    int      z_eof;   /* set if end of input file */
+    FILE     *file;   /* .gz file */
+    Byte     *inbuf;  /* input buffer */
+    Byte     *outbuf; /* output buffer */
+    uLong    crc;     /* crc32 of uncompressed data */
+    char     *msg;    /* error message */
+    char     *path;   /* path name for debugging only */
+    int      transparent; /* 1 if input file is not a .gz file */
+    char     mode;    /* 'w' or 'r' */
+    long     startpos; /* start of compressed data in file (header skipped) */
+} gz_stream;
+
+/* maximum number of simultaneous open files, also greater file descriptor number */
+#define MAXFD	64
+
+/* this static list is assumed to be filled with NULLs at runtime */
+static gzFile gzf_fds[MAXFD];
+
+/* returns the filedesc of the opened file. */
+int gzf_open(const char *name, int mode) {
+    int fd;
+    gzFile g;
+
+    if ((g=gzopen(name, "rb")) != NULL) {
+	fd=fileno(((gz_stream*)g)->file);
+	gzf_fds[fd]=g;
+    }
+    else if ((fd=open(name, mode)) != -1) {
+	gzf_fds[fd]=NULL; /* NULL means not GZ mode */
+    }
+    return fd;
+}
+
+off_t gzf_lseek(int fd, off_t offset, int whence) {
+    if (fd<0 || fd>=MAXFD || gzf_fds[fd]==NULL)
+	return lseek(fd, offset, whence);
+    else
+	return gzseek(gzf_fds[fd], offset, whence);
+}
+
+int gzf_read(int fd, void *buf, size_t count) {
+    if (fd<0 || fd>=MAXFD || gzf_fds[fd]==NULL)
+	return read(fd, buf, count);
+    else
+	return gzread(gzf_fds[fd], buf, count);
+}
+
+void gzf_close(int fd) {
+    if (fd<0 || fd>=MAXFD || gzf_fds[fd]==NULL)
+	close(fd);
+    else
+	gzclose(gzf_fds[fd]);
+}
+#endif
+
diff -urN linux-2.4.37.11-orig//modutils/kallsyms.h linux-2.4.37.11-rescue//modutils/kallsyms.h
--- linux-2.4.37.11-orig//modutils/kallsyms.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/kallsyms.h	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,129 @@
+#ifndef MODUTILS_KALLSYMS_H
+#define MODUTILS_KALLSYMS_H 1
+
+/* kallsyms headers
+   Copyright 2000 Keith Owens <kaos@ocs.com.au>
+
+   This file is part of the Linux modutils.  It is exported to kernel
+   space so debuggers can access the kallsyms data.
+
+   The kallsyms data contains all the non-stack symbols from a kernel
+   or a module.  The kernel symbols are held between __start___kallsyms
+   and __stop___kallsyms.  The symbols for a module are accessed via
+   the struct module chain which is based at module_list.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* Have to (re)define these ElfW entries here because external kallsyms
+ * code does not have access to modutils/include/obj.h.  This code is
+ * included from user spaces tools (modutils) and kernel, they need
+ * different includes.
+ */
+
+#ifndef ELFCLASS32
+#ifdef __KERNEL__
+#include <linux/elf.h>
+#else	/* __KERNEL__ */
+#include <elf.h>
+#endif	/* __KERNEL__ */
+#endif	/* ELFCLASS32 */
+
+#ifndef ELFCLASSM
+#define ELFCLASSM ELF_CLASS
+#endif
+
+#ifndef ElfW
+# if ELFCLASSM == ELFCLASS32
+#  define ElfW(x)  Elf32_ ## x
+#  define ELFW(x)  ELF32_ ## x
+# else
+#  define ElfW(x)  Elf64_ ## x
+#  define ELFW(x)  ELF64_ ## x
+# endif
+#endif
+
+/* Format of data in the kallsyms section.
+ * Most of the fields are small numbers but the total size and all
+ * offsets can be large so use the 32/64 bit types for these fields.
+ *
+ * Do not use sizeof() on these structures, modutils may be using extra
+ * fields.  Instead use the size fields in the header to access the
+ * other bits of data.
+ */
+
+struct kallsyms_header {
+	int		size;		/* Size of this header */
+	ElfW(Word)	total_size;	/* Total size of kallsyms data */
+	int		sections;	/* Number of section entries */
+	ElfW(Off)	section_off;	/* Offset to first section entry */
+	int		section_size;	/* Size of one section entry */
+	int		symbols;	/* Number of symbol entries */
+	ElfW(Off)	symbol_off;	/* Offset to first symbol entry */
+	int		symbol_size;	/* Size of one symbol entry */
+	ElfW(Off)	string_off;	/* Offset to first string */
+	ElfW(Addr)	start;		/* Start address of first section */
+	ElfW(Addr)	end;		/* End address of last section */
+};
+
+struct kallsyms_section {
+	ElfW(Addr)	start;		/* Start address of section */
+	ElfW(Word)	size;		/* Size of this section */
+	ElfW(Off)	name_off;	/* Offset to section name */
+	ElfW(Word)	flags;		/* Flags from section */
+};
+
+struct kallsyms_symbol {
+	ElfW(Off)	section_off;	/* Offset to section that owns this symbol */
+	ElfW(Addr)	symbol_addr;	/* Address of symbol */
+	ElfW(Off)	name_off;	/* Offset to symbol name */
+};
+
+#define KALLSYMS_SEC_NAME "__kallsyms"
+#define KALLSYMS_IDX 2			/* obj_kallsyms creates kallsyms as section 2 */
+
+#define kallsyms_next_sec(h,s) \
+	((s) = (struct kallsyms_section *)((char *)(s) + (h)->section_size))
+#define kallsyms_next_sym(h,s) \
+	((s) = (struct kallsyms_symbol *)((char *)(s) + (h)->symbol_size))
+
+int kallsyms_symbol_to_address(
+	const char       *name,			/* Name to lookup */
+	unsigned long    *token,		/* Which module to start with */
+	const char      **mod_name,		/* Set to module name or "kernel" */
+	unsigned long    *mod_start,		/* Set to start address of module */
+	unsigned long    *mod_end,		/* Set to end address of module */
+	const char      **sec_name,		/* Set to section name */
+	unsigned long    *sec_start,		/* Set to start address of section */
+	unsigned long    *sec_end,		/* Set to end address of section */
+	const char      **sym_name,		/* Set to full symbol name */
+	unsigned long    *sym_start,		/* Set to start address of symbol */
+	unsigned long    *sym_end		/* Set to end address of symbol */
+	);
+
+int kallsyms_address_to_symbol(
+	unsigned long     address,		/* Address to lookup */
+	const char      **mod_name,		/* Set to module name */
+	unsigned long    *mod_start,		/* Set to start address of module */
+	unsigned long    *mod_end,		/* Set to end address of module */
+	const char      **sec_name,		/* Set to section name */
+	unsigned long    *sec_start,		/* Set to start address of section */
+	unsigned long    *sec_end,		/* Set to end address of section */
+	const char      **sym_name,		/* Set to full symbol name */
+	unsigned long    *sym_start,		/* Set to start address of symbol */
+	unsigned long    *sym_end		/* Set to end address of symbol */
+	);
+
+#endif /* kallsyms.h */
diff -urN linux-2.4.37.11-orig//modutils/kerneld.h linux-2.4.37.11-rescue//modutils/kerneld.h
--- linux-2.4.37.11-orig//modutils/kerneld.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/kerneld.h	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,44 @@
+/* Definitions for the Linux kerneld SYSV IPC interface.
+   This file was part of the Linux kernel, and so is covered by the GPL.  */
+
+#ifndef MODUTILS_KERNELD_H
+#define MODUTILS_KERNELD_H
+
+#define KERNELD_SYSTEM 1
+#define KERNELD_REQUEST_MODULE 2		/* "insmod" */
+#define KERNELD_RELEASE_MODULE 3		/* "rmmod" */
+#define KERNELD_DELAYED_RELEASE_MODULE 4	/* "rmmod" */
+#define KERNELD_CANCEL_RELEASE_MODULE 5		/* "rmmod" */
+#define KERNELD_REQUEST_ROUTE 6			/* net/ipv4/route.c */
+#define KERNELD_BLANKER 7			/* drivers/char/console.c */
+#define KERNELD_PNP 8				/* drivers/pnp/kerneld.c */
+#define KERNELD_ARP 256				/* net/ipv4/arp.c */
+
+#ifdef NEW_KERNELD_PROTOCOL
+# define OLDIPC_KERNELD 00040000	/* old kerneld message channel */
+# define IPC_KERNELD 00140000		/* new kerneld message channel */
+# define KDHDR (sizeof(long) + sizeof(short) + sizeof(short))
+# define NULL_KDHDR 0, 2, 0
+#else /* NEW_KERNELD_PROTOCOL */
+# define IPC_KERNELD 00040000
+# define KDHDR (sizeof(long))
+# define NULL_KDHDR 0
+#endif /* NEW_KERNELD_PROTOCOL */
+
+#define KERNELD_MAXCMD 0x7ffeffff
+#define KERNELD_MINSEQ 0x7fff0000 /* "commands" legal up to 0x7ffeffff */
+#define KERNELD_WAIT 0x80000000
+#define KERNELD_NOWAIT 0
+
+struct kerneld_msg
+  {
+    long mtype;
+    long id;
+#ifdef NEW_KERNELD_PROTOCOL
+    short version;
+    short pid;
+#endif /* NEW_KERNELD_PROTOCOL */
+    char text[1];
+  };
+
+#endif /* kerneld.h */
diff -urN linux-2.4.37.11-orig//modutils/keywords.c linux-2.4.37.11-rescue//modutils/keywords.c
--- linux-2.4.37.11-orig//modutils/keywords.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/keywords.c	2010-12-31 14:20:29.073587351 +0100
@@ -0,0 +1,144 @@
+/* C code produced by gperf version 2.7.2 */
+/* Command-line: gperf -a -C -E -g -H is_reserved_hash -k '1,3,$' -N is_reserved_word -p -t keywords.gperf  */
+struct resword { const char *name; int token; };
+/* maximum key range = 101, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+is_reserved_hash (str, len)
+     register const char *str;
+     register unsigned int len;
+{
+  static const unsigned char asso_values[] =
+    {
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105,   5,
+      105, 105, 105, 105, 105, 105,   0, 105, 105, 105,
+        0, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105,   0, 105,   0, 105,  20,
+       25,   0,  35,  30, 105,  20, 105, 105,  40,  30,
+       30,   0,   0, 105,   0,   0,   0,  15,   5, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105, 105, 105, 105, 105,
+      105, 105, 105, 105, 105, 105
+    };
+  return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[0]] + asso_values[(unsigned char)str[len - 1]];
+}
+
+#ifdef __GNUC__
+__inline
+#endif
+const struct resword *
+is_reserved_word (str, len)
+     register const char *str;
+     register unsigned int len;
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 39,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 17,
+      MIN_HASH_VALUE = 4,
+      MAX_HASH_VALUE = 104
+    };
+
+  static const struct resword wordlist[] =
+    {
+      {""}, {""}, {""}, {""},
+      {"auto", AUTO_KEYW},
+      {"short", SHORT_KEYW},
+      {"struct", STRUCT_KEYW},
+      {"__asm__", ASM_KEYW},
+      {"restrict", RESTRICT_KEYW},
+      {"_restrict", RESTRICT_KEYW},
+      {"__signed__", SIGNED_KEYW},
+      {"__attribute", ATTRIBUTE_KEYW},
+      {"__restrict__", RESTRICT_KEYW},
+      {"__attribute__", ATTRIBUTE_KEYW},
+      {""},
+      {"__volatile", VOLATILE_KEYW},
+      {""},
+      {"__volatile__", VOLATILE_KEYW},
+      {"EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW},
+      {""}, {""}, {""},
+      {"EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
+      {"int", INT_KEYW},
+      {"char", CHAR_KEYW},
+      {""},
+      {"static", STATIC_KEYW},
+      {"__const", CONST_KEYW},
+      {"__inline", INLINE_KEYW},
+      {"__const__", CONST_KEYW},
+      {"__inline__", INLINE_KEYW},
+      {""}, {""},
+      {"__signed", SIGNED_KEYW},
+      {""},
+      {"__asm", ASM_KEYW},
+      {"extern", EXTERN_KEYW},
+      {""},
+      {"register", REGISTER_KEYW},
+      {""},
+      {"float", FLOAT_KEYW},
+      {""},
+      {"typedef", TYPEDEF_KEYW},
+      {""}, {""},
+      {"_Bool", BOOL_KEYW},
+      {"double", DOUBLE_KEYW},
+      {""},
+      {"unsigned", UNSIGNED_KEYW},
+      {"enum", ENUM_KEYW},
+      {""}, {""}, {""},
+      {"volatile", VOLATILE_KEYW},
+      {"void", VOID_KEYW},
+      {"const", CONST_KEYW},
+      {""}, {""}, {""}, {""}, {""},
+      {"signed", SIGNED_KEYW},
+      {""},
+      {"asm", ASM_KEYW},
+      {""}, {""},
+      {"inline", INLINE_KEYW},
+      {""}, {""}, {""},
+      {"union", UNION_KEYW},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""},
+      {"long", LONG_KEYW}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = is_reserved_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register const char *s = wordlist[key].name;
+
+          if (*str == *s && !strcmp (str + 1, s + 1))
+            return &wordlist[key];
+        }
+    }
+  return 0;
+}
diff -urN linux-2.4.37.11-orig//modutils/lex.c linux-2.4.37.11-rescue//modutils/lex.c
--- linux-2.4.37.11-orig//modutils/lex.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/lex.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,2764 @@
+#line 2 "lex.c"
+
+#line 4 "lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* %if-c++-only */
+/* %endif */
+
+/* %if-c-only */
+    
+/* %endif */
+
+/* %if-c-only */
+
+/* %endif */
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+/* %if-c-only */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+/* %endif */
+
+/* %if-tables-serialization */
+/* %endif */
+/* end standard C headers. */
+
+/* %if-c-or-c++ */
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* %not-for-header */
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+/* %ok-for-header */
+
+/* %if-reentrant */
+/* %endif */
+
+/* %if-not-reentrant */
+
+/* %endif */
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+/* %if-not-reentrant */
+extern int yyleng;
+/* %endif */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+extern FILE *yyin, *yyout;
+/* %endif */
+/* %endif */
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+/* %if-c-only */
+	FILE *yy_input_file;
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+/* %if-not-reentrant */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+/* %endif */
+/* %ok-for-header */
+
+/* %endif */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* %if-c-only Standard (non-C++) definition */
+
+/* %if-not-reentrant */
+/* %not-for-header */
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+/* %ok-for-header */
+
+/* %endif */
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+/* %endif */
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
+/* Begin user sect3 */
+
+#define yywrap() 1
+#define YY_SKIP_YYWRAP
+
+#define FLEX_DEBUG
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+/* %if-c-only Standard (non-C++) definition */
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* %endif */
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+/* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */\
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+/* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */\
+	(yy_c_buf_p) = yy_cp;
+
+/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
+#define YY_NUM_RULES 13
+#define YY_END_OF_BUFFER 14
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[76] =
+    {   0,
+        0,    0,    0,    0,   14,   12,    4,    3,   12,   12,
+       12,    7,    7,   12,   12,   12,   12,   12,    9,    9,
+       12,   12,   12,    4,    0,    5,    0,    0,    6,    0,
+        0,    7,    0,    0,    0,    0,    2,    8,   10,   10,
+        9,    0,    0,    9,    9,    0,    9,    0,    0,   11,
+        0,    0,    0,   10,    0,   10,    9,    9,    0,    0,
+        0,    0,    0,    0,    0,   10,   10,    0,    0,    0,
+        0,    0,    0,    1,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        4,    4,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    5,    6,    1,    7,    8,    9,    1,
+        1,    7,   10,    1,   11,   12,    7,   13,   14,   14,
+       14,   14,   14,   14,   14,   15,   15,    1,    1,   16,
+       17,   18,    1,    1,   19,   19,   19,   19,   20,   21,
+       22,   22,   22,   22,   22,   23,   22,   22,   22,   22,
+       22,   22,   22,   22,   24,   22,   22,   25,   22,   22,
+        1,   26,    1,    7,   22,    1,   19,   19,   19,   19,
+
+       20,   21,   22,   22,   22,   22,   22,   27,   22,   22,
+       22,   22,   22,   22,   22,   22,   24,   22,   22,   25,
+       22,   22,    1,   28,    1,    7,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[29] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    3,
+        3,    4,    5,    5,    5,    1,    1,    1,    6,    7,
+        6,    8,    8,    8,    8,    1,    8,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[88] =
+    {   0,
+        0,  166,   22,  152,  151,  282,   39,  282,   26,   33,
+      138,    0,   39,   43,  124,   39,   36,   48,   52,   55,
+       41,   56,   54,   47,   73,  282,    0,   72,  282,    0,
+      116,    0,   78,   75,  122,  103,  282,  282,  106,    0,
+       97,   73,   76,   91,   65,    0,    0,   84,   81,  282,
+      132,   98,   84,  282,  117,  147,  282,   73,  134,   89,
+      100,  140,  172,  139,  134,  181,  282,  135,  106,  142,
+      168,   88,   52,  282,  282,  208,  216,  220,  228,  236,
+      244,  249,  254,  255,  260,  265,  273
+    } ;
+
+static yyconst flex_int16_t yy_def[88] =
+    {   0,
+       75,    1,    1,    3,   75,   75,   75,   75,   76,   77,
+       75,   78,   78,   79,   75,   75,   75,   75,   75,   19,
+       75,   75,   75,   75,   76,   75,   80,   77,   75,   81,
+       75,   78,   76,   77,   79,   79,   75,   75,   75,   39,
+       19,   82,   83,   75,   75,   84,   20,   76,   77,   75,
+       79,   51,   85,   75,   75,   75,   75,   84,   79,   51,
+       79,   79,   79,   51,   75,   75,   75,   86,   79,   63,
+       86,   87,   87,   75,    0,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75
+    } ;
+
+static yyconst flex_int16_t yy_nxt[311] =
+    {   0,
+        6,    7,    8,    7,    9,    6,    6,    6,   10,    6,
+        6,   11,    6,    6,    6,    6,    6,    6,   12,   12,
+       12,   12,   13,   12,   12,    6,   12,    6,   15,   16,
+       26,   15,   17,   18,   19,   20,   20,   21,   15,   22,
+       24,   29,   24,   33,   36,   37,   38,   34,   24,   23,
+       24,   27,   38,   38,   74,   38,   38,   38,   30,   31,
+       39,   39,   39,   40,   41,   41,   42,   47,   47,   47,
+       38,   43,   38,   38,   44,   45,   46,   26,   44,   75,
+       29,   38,   26,   29,   40,   55,   55,   57,   26,   29,
+       74,   57,   43,   65,   65,   44,   45,   30,   27,   44,
+
+       30,   59,   37,   27,   36,   37,   30,   59,   37,   27,
+       64,   64,   64,   35,   57,   51,   52,   52,   39,   39,
+       39,   75,   35,   69,   37,   53,   54,   50,   54,   56,
+       56,   56,   54,   59,   37,   59,   37,   37,   68,   35,
+       38,   59,   37,   59,   60,   60,   66,   66,   66,   31,
+       75,   64,   64,   64,   61,   62,   63,   14,   61,   56,
+       56,   56,   69,   35,   61,   62,   69,   67,   61,   67,
+       37,   14,   72,   67,   37,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   70,   70,   70,   75,   75,   75,
+       70,   70,   70,   66,   66,   66,   75,   75,   75,   75,
+
+       75,   54,   75,   54,   75,   75,   75,   54,   25,   25,
+       25,   25,   25,   25,   25,   25,   28,   28,   28,   28,
+       28,   28,   28,   28,   32,   32,   32,   32,   35,   35,
+       35,   35,   35,   35,   35,   35,   48,   75,   48,   48,
+       48,   48,   48,   48,   49,   75,   49,   49,   49,   49,
+       49,   49,   42,   42,   75,   42,   56,   75,   56,   58,
+       58,   58,   66,   75,   66,   71,   71,   71,   71,   71,
+       71,   71,   71,   73,   73,   73,   73,   73,   73,   73,
+       73,    5,   75,   75,   75,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75
+    } ;
+
+static yyconst flex_int16_t yy_chk[311] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    3,    3,
+        9,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        7,   10,    7,   13,   14,   14,   16,   13,   24,    3,
+       24,    9,   17,   17,   73,   16,   21,   21,   10,   18,
+       18,   18,   18,   19,   19,   19,   19,   20,   20,   20,
+       23,   19,   22,   22,   19,   19,   19,   25,   19,   20,
+       28,   23,   33,   34,   42,   43,   43,   45,   48,   49,
+       72,   45,   42,   53,   53,   58,   58,   28,   25,   58,
+
+       34,   61,   61,   33,   36,   36,   49,   69,   69,   48,
+       52,   52,   52,   60,   44,   36,   36,   36,   39,   39,
+       39,   41,   52,   61,   35,   39,   39,   31,   39,   55,
+       55,   55,   39,   51,   51,   59,   59,   68,   59,   68,
+       15,   62,   62,   70,   51,   51,   65,   65,   65,   11,
+        5,   64,   64,   64,   51,   51,   51,    4,   51,   56,
+       56,   56,   62,   64,   70,   70,   62,   56,   70,   56,
+       71,    2,   71,   56,   63,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   63,   63,   63,    0,    0,    0,
+       63,   63,   63,   66,   66,   66,    0,    0,    0,    0,
+
+        0,   66,    0,   66,    0,    0,    0,   66,   76,   76,
+       76,   76,   76,   76,   76,   76,   77,   77,   77,   77,
+       77,   77,   77,   77,   78,   78,   78,   78,   79,   79,
+       79,   79,   79,   79,   79,   79,   80,    0,   80,   80,
+       80,   80,   80,   80,   81,    0,   81,   81,   81,   81,
+       81,   81,   82,   82,    0,   82,   83,    0,   83,   84,
+       84,   84,   85,    0,   85,   86,   86,   86,   86,   86,
+       86,   86,   86,   87,   87,   87,   87,   87,   87,   87,
+       87,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 1;
+
+static yyconst flex_int16_t yy_rule_linenum[13] =
+    {   0,
+       70,   71,   72,   75,   78,   79,   80,   86,   87,   88,
+       93,   96
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "lex.l"
+/* Lexical analysis for genksyms.
+   Copyright 1996, 1997 Linux International.
+
+   New implementation contributed by Richard Henderson <rth@tamu.edu>
+   Based on original work by Bjorn Ekwall <bj0rn@blox.se>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+#line 25 "lex.l"
+
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "genksyms.h"
+#include "parse.h"
+#include "util.h"
+
+/* We've got a two-level lexer here.  We let flex do basic tokenization
+   and then we categorize those basic tokens in the second stage.  */
+#define YY_DECL		static int yylex1(void)
+
+/* Version 2 checksumming does proper tokenization; version 1 wasn't
+   quite so pedantic.  */
+
+/* We don't do multiple input files.  */
+#line 668 "lex.c"
+
+#define INITIAL 0
+#define V2_TOKENS 1
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+/* %if-c-only */
+#include <unistd.h>
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+/* %if-c-only Reentrant structure and macros (non-C++). */
+/* %if-reentrant */
+/* %if-c-only */
+
+static int yy_init_globals (void );
+
+/* %endif */
+/* %if-reentrant */
+/* %endif */
+/* %if-bison-bridge */
+/* %endif */
+/* %endif End reentrant structures and macros. */
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+/* %not-for-header */
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+/* %ok-for-header */
+
+/* %endif */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+/* %ok-for-header */
+
+/* %endif */
+#endif
+
+/* %if-c-only */
+
+/* %endif */
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* %if-c-only Standard (non-C++) definition */
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+/* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */\
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+/* %if-c++-only C++ definition \ */\
+/* %endif */
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+/* %if-c-only */
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+/* %if-tables-serialization structures and prototypes */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* %tables-yydmap generated elements */
+/* %endif */
+/* end tables serialization structures and prototypes */
+
+/* %ok-for-header */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+/* %if-c-only Standard (non-C++) definition */
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+/* %% [6.0] YY_RULE_SETUP definition goes here */
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/* %not-for-header */
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+/* %% [7.0] user's declarations go here */
+#line 66 "lex.l"
+
+
+
+ /* Keep track of our location in the original source files.  */
+#line 889 "lex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+/* %if-c-only */
+			yyin = stdin;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! yyout )
+/* %if-c-only */
+			yyout = stdout;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+/* %% [8.0] yymore()-related code goes here */
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+/* %% [9.0] code to set up and find next match goes here */
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 76 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 282 );
+
+yy_find_action:
+/* %% [10.0] code to find the action number goes here */
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+/* %% [11.0] code for yylineno update goes here */
+
+do_action:	/* This label is used only to access EOF actions. */
+
+/* %% [12.0] debug code goes here */
+		if ( yy_flex_debug )
+			{
+			if ( yy_act == 0 )
+				fprintf( stderr, "--scanner backing up\n" );
+			else if ( yy_act < 13 )
+				fprintf( stderr, "--accepting rule at line %ld (\"%s\")\n",
+				         (long)yy_rule_linenum[yy_act], yytext );
+			else if ( yy_act == 13 )
+				fprintf( stderr, "--accepting default rule (\"%s\")\n",
+				         yytext );
+			else if ( yy_act == 14 )
+				fprintf( stderr, "--(end of buffer or a NUL)\n" );
+			else
+				fprintf( stderr, "--EOF (start condition %d)\n", YY_START );
+			}
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+/* %% [13.0] actions go here */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 70 "lex.l"
+return FILENAME;
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 71 "lex.l"
+cur_line++;
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 72 "lex.l"
+cur_line++;
+	YY_BREAK
+/* Ignore all other whitespace.  */
+case 4:
+YY_RULE_SETUP
+#line 75 "lex.l"
+;
+	YY_BREAK
+case 5:
+/* rule 5 can match eol */
+YY_RULE_SETUP
+#line 78 "lex.l"
+return STRING;
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 79 "lex.l"
+return CHAR;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 80 "lex.l"
+return IDENT;
+	YY_BREAK
+/* The Pedant requires that the other C multi-character tokens be
+    recognized as tokens.  We don't actually use them since we don't
+    parse expressions, but we do want whitespace to be arranged
+    around them properly.  */
+case 8:
+YY_RULE_SETUP
+#line 86 "lex.l"
+return OTHER;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 87 "lex.l"
+return INT;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 88 "lex.l"
+return REAL;
+	YY_BREAK
+/* Version 1 checksums didn't recognize ellipsis as a token, but we
+    need it for proper parsing.  We'll take care of backward compatibility
+    by altering the text of the token in the second stage lexer.  */
+case 11:
+YY_RULE_SETUP
+#line 93 "lex.l"
+return DOTS;
+	YY_BREAK
+/* All other tokens are single characters.  */
+case 12:
+YY_RULE_SETUP
+#line 96 "lex.l"
+return yytext[0];
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 99 "lex.l"
+ECHO;
+	YY_BREAK
+#line 1083 "lex.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(V2_TOKENS):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+/* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+/* %ok-for-header */
+
+/* %if-c++-only */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %endif */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+/* %if-c-only */
+static int yy_get_next_buffer (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+/* %if-c-only */
+/* %not-for-header */
+
+    static yy_state_type yy_get_previous_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+/* %% [15.0] code to get the start state into yy_current_state goes here */
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+/* %% [16.0] code to find the next state goes here */
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 76 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+/* %if-c-only */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register int yy_is_jam;
+    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
+	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 76 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 75);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+/* %if-c-only */
+
+    static void yyunput (int c, register char * yy_bp )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+/* %% [18.0] update yylineno here */
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+/* %if-c-only */
+
+/* %endif */
+
+/* %if-c-only */
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+/* %% [19.0] update BOL and yylineno */
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+/* %if-c-only */
+#endif	/* ifndef YY_NO_INPUT */
+/* %endif */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+/* %if-c-only */
+    void yyrestart  (FILE * input_file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+/* %if-c-only */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/* %if-c-only */
+static void yy_load_buffer_state  (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+/* %if-c-only */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+/* %if-c-only */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+/* %if-c-only */
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+/* %if-c-only */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+/* %if-c-only */
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+/* %if-c-only */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/* %if-c-or-c++ */
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+/* %if-c-only */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+/* %if-c-only */
+void yypop_buffer_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+/* %if-c-only */
+static void yyensure_buffer_stack (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+/* %endif */
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+/* %if-c-only */
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/* %if-c-only */
+/* %if-reentrant */
+/* %endif */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/* %if-reentrant */
+/* %endif */
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+/* %endif */
+
+/* %if-reentrant */
+/* %if-bison-bridge */
+/* %endif */
+/* %endif */
+
+/* %if-c-only */
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/* %if-c-only */
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+/* %if-c++-only */
+/* %endif */
+
+/* %if-c-only */
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+/* %if-reentrant */
+/* %endif */
+    return 0;
+/* %endif */
+}
+/* %endif */
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+/* %if-tables-serialization definitions */
+/* %define-yytables   The name for this specific scanner's tables. */
+#define YYTABLES_NAME "yytables"
+/* %endif */
+
+/* %ok-for-header */
+
+#line 99 "lex.l"
+
+
+
+/* Bring in the keyword recognizer.  */
+
+#include "keywords.c"
+
+
+/* Macros to append to our phrase collection list.  */
+
+#define _APP(T,L)	do {						   \
+			  cur_node = next_node;				   \
+			  next_node = xmalloc(sizeof(*next_node));	   \
+			  next_node->next = cur_node;			   \
+			  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \
+			  cur_node->tag = SYM_NORMAL;			   \
+			} while (0)
+
+#define APP		_APP(yytext, yyleng)
+
+
+/* The second stage lexer.  Here we incorporate knowledge of the state
+   of the parser to tailor the tokens that are returned.  */
+
+int
+yylex(void)
+{
+  static enum {
+    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_BRACKET, ST_BRACE,
+    ST_EXPRESSION, ST_TABLE_1, ST_TABLE_2, ST_TABLE_3, ST_TABLE_4,
+    ST_TABLE_5, ST_TABLE_6
+  } lexstate = ST_NOTSTARTED;
+
+  static int suppress_type_lookup, dont_want_brace_phrase;
+  static struct string_list *next_node;
+
+  int token, count = 0;
+  struct string_list *cur_node;
+
+  if (lexstate == ST_NOTSTARTED)
+    {
+      if (checksum_version > 1)
+	BEGIN(V2_TOKENS);
+      next_node = xmalloc(sizeof(*next_node));
+      next_node->next = NULL;
+      lexstate = ST_NORMAL;
+    }
+
+repeat:
+  token = yylex1();
+
+  if (token == 0)
+    return 0;
+  else if (token == FILENAME)
+    {
+      char *file, *e;
+
+      /* Save the filename and line number for later error messages.  */
+
+      if (cur_filename)
+	free(cur_filename);
+
+      file = strchr(yytext, '\"')+1;
+      e = strchr(file, '\"');
+      *e = '\0';
+      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);
+      cur_line = atoi(yytext+2);
+
+      /* Linux kernels 2.1.18 and above (roughly) get to ignore the
+	 hackery below.  */
+      if (checksum_version == 1)
+	{
+	  static const char symtab_begin[] = "linux/symtab_begin.h";
+	  static const char symtab_end[] = "linux/symtab_end.h";
+
+	  /* When building 2.0 kernels, we are only given the output directory
+	     and we're supposed to deduce the output filename from the cpp
+	     output.  */
+
+	  if (outfile == NULL)
+	    {
+	      char buffer[PATH_MAX], *dot, *p, *q, *f;
+
+	      dot = strrchr(file, '.');
+	      f = strrchr(file, '/');
+
+	      if (dot) *dot = '\0';
+	      f = (f ? f+1 : file);
+
+	      snprintf(buffer, sizeof(buffer), "%s/%s.ver", output_directory, f);
+
+	      if ((outfile = fopen(buffer, "w")) == NULL)
+		{
+		  perror(buffer);
+		  exit(1);
+		}
+
+	      fputs("/* This file is generated by genksyms  DO NOT EDIT! */\n"
+		    "#if (defined(CONFIG_MODVERSIONS) || defined(MODVERSIONS))"
+		    " && !defined(__GENKSYMS__)\n", outfile);
+
+	      q = buffer;
+	      *q++ = '_';
+	      for (p = f; *p ; ++p, ++q)
+		*q = (*p == '.' ? '_' : toupper(*p));
+	      memcpy(q, "_VER_", 6);
+
+	      fprintf(outfile, "#ifndef %s\n", buffer);
+	      fprintf(outfile, "#define %s\n", buffer);
+
+	      if (dot) *dot = '.';
+	    }
+
+	  /* For 2.0 kernels, symbol tables are constructed in big initialized
+	     arrays that begin by including <linux/symtab_begin.h> and end by
+	     including <linux/symtab_end.h>.  We're going to transmute this
+	     little bit o' nastiness into something that, from the perspective
+	     of the grammar, resembles the 2.1 scheme in the following
+	     fashion:
+
+	     When we see a file name with a suffix matching symtab_begin we
+	     should be in ST_EXPRESSION, having already seen the "= {" bits.
+	     We get the grammar back to top-level in two stages, by returning
+	     EXPRESSION_PHRASE then ';' as we move through ST_TABLE_1 to
+	     ST_TABLE_2 eating the tokens we find that were contained in
+	     symtab_begin.h.  The body of the work is done in ST_TABLE_{2,5,6}
+	     by transmuting X to EXPORT_SYMBOL and ',' to ';'.  We return
+	     to normal mode when we see a file name with a suffix matching
+	     symtab_end.h.
+
+	     This is not particularly pretty, but it is better than either
+	     truely parsing expressions or some other bit o hackery to always
+	     recognize and record "X" tokens for later perusal.  */
+
+	  if (e-file > sizeof(symtab_begin)
+	      && strcmp(e-sizeof(symtab_begin)+1, symtab_begin) == 0)
+	    {
+	      if (lexstate != ST_TABLE_1)
+		{
+		  lexstate = ST_TABLE_1;
+		  return EXPRESSION_PHRASE;
+		}
+	    }
+	  else if (e-file > sizeof(symtab_end)
+		   && strcmp(e-sizeof(symtab_end)+1, symtab_end) == 0)
+	    lexstate = ST_TABLE_3;
+	  else if (lexstate == ST_TABLE_1)
+	    {
+	      lexstate = ST_TABLE_2;
+	      return ';';
+	    }
+	  else if (lexstate == ST_TABLE_3)
+	    lexstate = ST_TABLE_4;
+	}
+
+      goto repeat;
+    }
+
+  switch (lexstate)
+    {
+    case ST_NORMAL:
+      switch (token)
+	{
+	case IDENT:
+	  APP;
+	  {
+	    const struct resword *r = is_reserved_word(yytext, yyleng);
+	    if (r)
+	      {
+		switch (token = r->token)
+		  {
+		  case ATTRIBUTE_KEYW:
+		    lexstate = ST_ATTRIBUTE;
+		    count = 0;
+		    goto repeat;
+		  case ASM_KEYW:
+		    lexstate = ST_ASM;
+		    count = 0;
+		    goto repeat;
+
+		  case STRUCT_KEYW:
+		  case UNION_KEYW:
+		    dont_want_brace_phrase = 3;
+		  case ENUM_KEYW:
+		    suppress_type_lookup = 2;
+		    goto fini;
+
+		  case EXPORT_SYMBOL_KEYW:
+		    if (checksum_version > 1)
+		      goto fini;
+		    else
+		      token = IDENT;
+		  }
+	      }
+	    if (!suppress_type_lookup)
+	      {
+		struct symbol *sym = find_symbol(yytext, SYM_TYPEDEF);
+		if (sym && sym->type == SYM_TYPEDEF)
+		  token = TYPE;
+	      }
+	  }
+	  break;
+
+	case '[':
+	  APP;
+	  lexstate = ST_BRACKET;
+	  count = 1;
+	  goto repeat;
+
+	case '{':
+	  APP;
+	  if (dont_want_brace_phrase)
+	    break;
+	  lexstate = ST_BRACE;
+	  count = 1;
+	  goto repeat;
+
+	case '=': case ':':
+	  APP;
+	  lexstate = ST_EXPRESSION;
+	  break;
+
+	case DOTS:
+	  if (checksum_version == 1)
+	    {
+	      _APP(". . .", 5);
+	      break;
+	    }
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    case ST_ATTRIBUTE:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ATTRIBUTE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_ASM:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ASM_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACKET:
+      APP;
+      switch (token)
+	{
+	case '[':
+	  ++count;
+	  goto repeat;
+	case ']':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACKET_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACE:
+      APP;
+      switch (token)
+	{
+	case '{':
+	  ++count;
+	  goto repeat;
+	case '}':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_EXPRESSION:
+      switch (token)
+	{
+	case '(': case '[': case '{':
+	  ++count;
+	  APP;
+	  goto repeat;
+	case ')': case ']': case '}':
+	  --count;
+	  APP;
+	  goto repeat;
+	case ',': case ';':
+	  if (count == 0)
+	    {
+	      /* Put back the token we just read so's we can find it again
+		 after registering the expression.  */
+	      unput(token);
+
+	      lexstate = ST_NORMAL;
+	      token = EXPRESSION_PHRASE;
+	      break;
+	    }
+	  APP;
+	  goto repeat;
+	default:
+	  APP;
+	  goto repeat;
+	}
+      break;
+
+    case ST_TABLE_1:
+      goto repeat;
+
+    case ST_TABLE_2:
+      if (token == IDENT && yyleng == 1 && yytext[0] == 'X')
+	{
+	  token = EXPORT_SYMBOL_KEYW;
+	  lexstate = ST_TABLE_5;
+	  APP;
+	  break;
+	}
+      lexstate = ST_TABLE_6;
+      /* FALLTHRU */
+
+    case ST_TABLE_6:
+      switch (token)
+	{
+	case '{': case '[': case '(':
+	  ++count;
+	  break;
+	case '}': case ']': case ')':
+	  --count;
+	  break;
+	case ',':
+	  if (count == 0)
+	    lexstate = ST_TABLE_2;
+	  break;
+	};
+      goto repeat;
+
+    case ST_TABLE_3:
+      goto repeat;
+
+    case ST_TABLE_4:
+      if (token == ';')
+	lexstate = ST_NORMAL;
+      goto repeat;
+
+    case ST_TABLE_5:
+      switch (token)
+	{
+	case ',':
+	  token = ';';
+	  lexstate = ST_TABLE_2;
+	  APP;
+	  break;
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    default:
+      abort();
+    }
+fini:
+
+  if (suppress_type_lookup > 0)
+    --suppress_type_lookup;
+  if (dont_want_brace_phrase > 0)
+    --dont_want_brace_phrase;
+
+  yylval = &next_node->next;
+
+  return token;
+}
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     FLOAT_KEYW = 267,
+     INLINE_KEYW = 268,
+     INT_KEYW = 269,
+     LONG_KEYW = 270,
+     REGISTER_KEYW = 271,
+     RESTRICT_KEYW = 272,
+     SHORT_KEYW = 273,
+     SIGNED_KEYW = 274,
+     STATIC_KEYW = 275,
+     STRUCT_KEYW = 276,
+     TYPEDEF_KEYW = 277,
+     UNION_KEYW = 278,
+     UNSIGNED_KEYW = 279,
+     VOID_KEYW = 280,
+     VOLATILE_KEYW = 281,
+     EXPORT_SYMBOL_KEYW = 282,
+     ASM_PHRASE = 283,
+     ATTRIBUTE_PHRASE = 284,
+     BRACE_PHRASE = 285,
+     BRACKET_PHRASE = 286,
+     EXPRESSION_PHRASE = 287,
+     CHAR = 288,
+     DOTS = 289,
+     IDENT = 290,
+     INT = 291,
+     REAL = 292,
+     STRING = 293,
+     TYPE = 294,
+     OTHER = 295,
+     FILENAME = 296
+   };
+#endif
+/* Tokens.  */
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define FLOAT_KEYW 267
+#define INLINE_KEYW 268
+#define INT_KEYW 269
+#define LONG_KEYW 270
+#define REGISTER_KEYW 271
+#define RESTRICT_KEYW 272
+#define SHORT_KEYW 273
+#define SIGNED_KEYW 274
+#define STATIC_KEYW 275
+#define STRUCT_KEYW 276
+#define TYPEDEF_KEYW 277
+#define UNION_KEYW 278
+#define UNSIGNED_KEYW 279
+#define VOID_KEYW 280
+#define VOLATILE_KEYW 281
+#define EXPORT_SYMBOL_KEYW 282
+#define ASM_PHRASE 283
+#define ATTRIBUTE_PHRASE 284
+#define BRACE_PHRASE 285
+#define BRACKET_PHRASE 286
+#define EXPRESSION_PHRASE 287
+#define CHAR 288
+#define DOTS 289
+#define IDENT 290
+#define INT 291
+#define REAL 292
+#define STRING 293
+#define TYPE 294
+#define OTHER 295
+#define FILENAME 296
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
+
diff -urN linux-2.4.37.11-orig//modutils/logger.c linux-2.4.37.11-rescue//modutils/logger.c
--- linux-2.4.37.11-orig//modutils/logger.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/logger.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,136 @@
+/* Error logging facilities.
+   Copyright 1996, 1997 Linux International.
+
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+  */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <syslog.h>
+
+#include "util.h"
+
+/*======================================================================*/
+
+int log;
+static int silent;
+
+int errors;
+const char *error_file;
+const char *program_name;
+
+#define STOREMSG
+#ifdef STOREMSG
+struct cbuf {
+	struct cbuf *next;
+	int type;
+	char *msg;
+} *head, *tail;
+
+static void savemsg(int type, char *msg)
+{
+	struct cbuf *me = (struct cbuf *)xmalloc(sizeof(struct cbuf));
+	char *s = xstrdup(msg);
+
+	me->next = NULL;
+	me->type = type;
+	me->msg = s;
+
+	if (tail)
+		tail->next = me;
+	else
+		head = me;
+	tail = me;
+}
+
+static void dumpmsg(void)
+{
+	for (;head; head = head->next)
+		syslog(head->type, "%s", head->msg);
+}
+#endif /* STOREMSG */
+
+void error(const char *fmt,...)
+{
+	va_list args;
+
+	if (silent)
+		;
+	else if (log) {
+		char buf[2*PATH_MAX];
+		int n;
+
+		if (error_file)
+			n = snprintf(buf, sizeof(buf), "%s: ", error_file);
+		else
+			n = 0;
+		va_start(args, fmt);
+		vsnprintf(buf + n, sizeof(buf) - n, fmt, args);
+		va_end(args);
+#ifdef STOREMSG
+		savemsg(LOG_ERR, buf);
+#else
+		syslog(LOG_ERR, "%s", buf);
+#endif
+	} else {
+		if (error_file)
+			fprintf(stderr, "%s: ", error_file);
+		va_start(args, fmt);
+		vfprintf(stderr, fmt, args);
+		va_end(args);
+		putc('\n', stderr);
+	}
+
+	errors++;
+}
+
+void lprintf(const char *fmt,...)
+{
+	va_list args;
+
+	if (silent);
+	else if (log) {
+		char buf[2*PATH_MAX];
+		va_start(args, fmt);
+		vsnprintf(buf, sizeof(buf), fmt, args);
+		va_end(args);
+#ifdef STOREMSG
+		savemsg(LOG_INFO, buf);
+#else
+		syslog(LOG_INFO, "%s", buf);
+#endif
+	} else {
+		va_start(args, fmt);
+		vfprintf(stdout, fmt, args);
+		va_end(args);
+		putchar('\n');
+	}
+}
+
+void setsyslog(const char *program)
+{
+	openlog(program, LOG_CONS, LOG_DAEMON);
+#ifdef STOREMSG
+	atexit(dumpmsg);
+#endif
+	log = 1;
+}
diff -urN linux-2.4.37.11-orig//modutils/makecrc32.c linux-2.4.37.11-rescue//modutils/makecrc32.c
--- linux-2.4.37.11-orig//modutils/makecrc32.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/makecrc32.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,62 @@
+/* Not copyrighted 1990 Mark Adler */
+
+#include <stdio.h>
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.  The table is
+  written to stdout as 256 long hexadecimal values in C language format.
+*/
+
+int
+main()
+{
+  unsigned long c;      /* crc shift register */
+  unsigned long e;      /* polynomial exclusive-or pattern */
+  int i;                /* counter for all possible eight bit values */
+  int k;                /* byte being shifted into crc apparatus */
+
+  /* terms of polynomial defining this crc (except x^32): */
+  static const int p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* Make exclusive-or pattern from polynomial */
+  e = 0;
+  for (i = 0; i < sizeof(p)/sizeof(int); i++)
+    e |= 1L << (31 - p[i]);
+
+  /* Compute and print table of CRC's, five per line */
+  printf("  0x00000000U");
+  for (i = 1; i < 256; i++)
+  {
+    c = 0;
+    for (k = i | 256; k != 1; k >>= 1)
+    {
+      c = c & 1 ? (c >> 1) ^ e : c >> 1;
+      if (k & 1)
+        c ^= e;
+    }
+    printf(i % 5 ? ", 0x%08lxU" : ",\n  0x%08lxU", c);
+  }
+  putchar('\n');
+  return 0;
+}
diff -urN linux-2.4.37.11-orig//modutils/Makefile linux-2.4.37.11-rescue//modutils/Makefile
--- linux-2.4.37.11-orig//modutils/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/Makefile	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,41 @@
+DEFS = -I. -D_GNU_SOURCE -DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DCONFIG_ROOT_CHECK_OFF=0  $(EXTRA_DEFS)
+DEFS += -DELF_MACHINE_H='"elf_$(ARCH).h"' -DARCH_$(ARCH) $(EXTRA_DEFS)
+
+OBJS = xmalloc.o xrealloc.o xstrcat.o xstrdup.o xsystem.o \
+	logger.o modstat.o \
+	meta_expand.o config.o snap_shot.o arch64.o gzfiles.o sys_nim.o \
+	xftw.o
+
+%.o: %.c
+	$(HOSTCC) $(HOSTCFLAGS) $(DEFS) -c -o $@ $<
+
+all: libutil.a genksyms
+
+genksyms: genksyms.o parse.o lex.o libutil.a
+	$(HOSTCC) $(HOSTCFLAGS) -o $@ $^
+
+parse.o: parse.c
+	$(HOSTCC) $(HOSTCFLAGS) $(DEFS) -c -o $@ $<
+
+lex.o: lex.c
+	$(HOSTCC) $(HOSTCFLAGS) $(DEFS) -c -o $@ $<
+
+crc32.tab: makecrc32.c
+	$(HOSTCC) $(HOSTCFLAGS) -o makecrc32 $^
+	./makecrc32 > $@.tmp
+	mv $@.tmp $@
+
+clean:
+	rm -f *.o *.a *.tmp parse.output genksyms makecrc32 crc32.tab
+
+genksyms.o: genksyms.c crc32.tab genksyms.h util.h version.h
+
+lex.o: lex.c keywords.c genksyms.h parse.c util.h
+
+parse.o: parse.c genksyms.h
+
+meta_expand.o: meta_expand.c
+	$(HOSTCC) $(HOSTCFLAGS) $(DEFS) -DHAVE_WORDEXP=1 -DHAVE_GLOB=1 -c $<
+
+libutil.a: $(OBJS)
+	$(AR) rv $@ $?
diff -urN linux-2.4.37.11-orig//modutils/meta_expand.c linux-2.4.37.11-rescue//modutils/meta_expand.c
--- linux-2.4.37.11-orig//modutils/meta_expand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/meta_expand.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,339 @@
+/*
+ * Handle expansion of meta charaters
+ *
+ * Copyright 1999 Björn Ekwall <bj0rn@blox.se>
+ *
+ * "kernelversion" idea from the Debian release via:
+ *	Wichert Akkerman <wakkerma@cs.leidenuniv.nl>
+ *
+ * Use wordexp(): idea from Tim Waugh <tim@cyberelk.demon.co.uk>
+ *
+ * Alpha typecast: Michal Jaegermann <michal@ellpspace.math.ualberta.ca>
+ *
+ * This file is part of the Linux modutils.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_WORDEXP
+#undef HAVE_WORDEXP
+#define HAVE_WORDEXP 0
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <string.h>
+#include <ctype.h>
+#if HAVE_WORDEXP
+#include <wordexp.h>
+#elif HAVE_GLOB
+#include <glob.h>
+#endif
+#include "util.h"
+
+/*
+ * Split into words delimited by whitespace,
+ * handle remaining quotes though...
+ * If strip_quotes != 0 then strip one level of quotes from the line.
+ */
+static void split_line(GLOB_LIST *g, char *line, int strip_quotes)
+{
+	int len;
+	char *d;
+	char *e;
+	char *p;
+	char tmpline[PATH_MAX];
+
+	for (p = line; *p; p = e) {
+		/* Skip leading whitespace */
+		while (*p && isspace(*p))
+			++p;
+
+		/* find end of word */
+		d = tmpline;
+		for (e = p; *e && !(isspace(*e)); ++e) {
+			char match;
+
+			/* Quote handling */
+			switch (*e) {
+			case '\\':
+				if (!strip_quotes)
+					*d++ = *e;
+				break;
+
+			case '"':
+			case '\'':
+				match = *e;
+				if (!strip_quotes)
+					*d++ = *e;
+				for (++e; *e && *e != match; ++e) {
+					*d++ = *e;
+					if (*e == '\\' && *(e + 1) == match)
+						*d++ = *++e;
+				}
+				if (!strip_quotes)
+					*d++ = *e;
+				break;
+
+			default:
+				*d++ = *e;
+				break;
+			}
+		}
+
+		if ((len = (int)(d - tmpline)) > 0) {
+			char *str = xmalloc(len + 1);
+			strncpy(str, tmpline, len);
+			str[len] = '\0';
+			g->pathv = (char **)xrealloc(g->pathv,
+				   (g->pathc + 2) * sizeof(char *));
+			g->pathv[g->pathc++] = str;
+		}
+	}
+
+	if (g->pathc)
+		g->pathv[g->pathc] = NULL;
+}
+
+static int glob_it(char *pt, GLOB_LIST *g)
+{
+#if HAVE_WORDEXP
+	wordexp_t w;
+
+	memset(&w, 0, sizeof(w));
+	if (wordexp(pt, &w, WRDE_UNDEF)) {
+		/*
+		error("wordexp %s failed", pt);
+		*/
+		return -1;
+	}
+	/* else */
+	g->pathc = w.we_wordc;
+	g->pathv = w.we_wordv;
+
+	return 0;
+#elif HAVE_GLOB /* but not wordexp */
+	glob_t w;
+
+	memset(&w, 0, sizeof(w));
+	if (glob(pt, GLOB_NOSORT, NULL, &w)) {
+		/*
+		error("glob %s failed", pt);
+		*/
+		return -1;
+	}
+	/* else */
+	if (w.gl_pathc && strpbrk(w.gl_pathv[0], SHELL_META)) {
+		globfree(&w);
+		return -1;
+	}
+	g->pathc = w.gl_pathc;
+	g->pathv = w.gl_pathv;
+
+	return 0;
+#else /* Neither wordexp nor glob */
+	return -1;
+#endif
+}
+
+/*
+ * Expand the string (including meta-character) to a list of matches
+ *
+ * Return 0 if OK else -1
+ */
+int meta_expand(char *pt, GLOB_LIST *g, char *base_dir, char *version, int type)
+{
+	FILE *fin;
+	int len = 0;
+	char *line = NULL;
+	char *p, *p1;
+	char tmpline[PATH_MAX + 1];
+	char wrk[sizeof(tmpline)];
+	char tmpcmd[2*sizeof(tmpline)+20];	/* room for /bin/echo "text" */
+
+	g->pathc = 0;
+	g->pathv = NULL;
+
+	/*
+	 * Take care of version dependent expansions
+	 * Needed for forced version handling
+	 */
+	if ((p = strchr(pt, '`')) != NULL && (type & ME_BUILTIN_COMMAND)) {
+		do {
+			char *s;
+
+			for (s = p + 1; isspace(*s); ++s)
+				;
+
+			if (strncmp(s, "uname -r", 8) == 0) {
+				while (*s && (*s != '`'))
+					++s;
+				if (*s == '`') {
+					*p = '\0';
+					snprintf(wrk, sizeof(wrk), "%s%s%s",
+						     pt,
+						     version,
+						     s + 1);
+					*p = '`';
+				}
+				strcpy(tmpline, wrk);	/* safe, same size */
+				pt = tmpline;
+			} else if (strncmp(s, "kernelversion", 13) == 0) {
+				while (*s && (*s != '`'))
+					++s;
+				if (*s == '`') {
+					int n;
+					char *k;
+
+					*p = '\0';
+					for (n = 0, k = version; *k; ++k) {
+						if (*k == '.' && ++n == 2)
+							break;
+					}
+					snprintf(wrk, sizeof(wrk), "%s%.*s%s",
+						     pt,
+						     /* typecast for Alpha */
+						     (int)(k - version),
+						     version,
+						     s + 1);
+					*p = '`';
+					strcpy(tmpline, wrk);	/* safe, same size */
+					pt = tmpline;
+				}
+			} else
+				break;
+		} while ((p = strchr(pt, '`')) != NULL);
+	}
+
+	/*
+	 * Any remaining meta-chars?
+	 */
+	if (strpbrk(pt, SHELL_META) == NULL) {
+		/*
+		 * No meta-chars.
+		 * Split into words, delimited by whitespace.
+		 */
+		snprintf(wrk, sizeof(wrk), "%s%s", (base_dir ? base_dir : ""), pt);
+		strcpy(tmpline, wrk);	/* safe, same size */
+		if ((p = strtok(tmpline, " \t\n")) != NULL) {
+			while (p) {
+				g->pathv = (char **)xrealloc(g->pathv,
+					   (g->pathc + 2) * sizeof(char *));
+				g->pathv[g->pathc++] = xstrdup(p);
+				p = strtok(NULL, " \t\n");
+			}
+		}
+		if (g->pathc)
+			g->pathv[g->pathc] = NULL;
+		return 0;
+	}
+	/* else */
+	/*
+	 * Handle remaining meta-chars
+	 */
+
+	/*
+	 * Just plain quotes?
+	 */
+	if (strpbrk(pt, "&();|<>$`!{}[]~=+:?*") == NULL &&
+	    (p = strpbrk(pt, "\"'\\"))) {
+		split_line(g, pt, 1);
+		return 0;
+	}
+
+	if (strpbrk(pt, "&();|<>$`\"'\\!{}~+:[]~?*") == NULL) {
+		/* Only "=" remaining, should be module options */
+		split_line(g, pt, 0);
+		return 0;
+	}
+
+	/*
+	 * If there are meta-characters and
+	 * if they are only shell glob meta-characters: do globbing
+	 */
+#if HAVE_WORDEXP
+	if (strpbrk(pt, "&();|<>`\"'\\!{}~=+:") == NULL &&
+	    strpbrk(pt, "$[]~?*"))
+#else
+	if (strpbrk(pt, "&();|<>$`\"'\\!{}~=+:") == NULL &&
+	    strpbrk(pt, "[]~?*"))
+#endif
+		if ((type & ME_GLOB) && glob_it(pt, g) == 0)
+			return 0;
+
+	if (strpbrk(pt, "&();|<>$`\"'\\!{}~+:[]~?*") == NULL) {
+		/* Only "=" remaining, should be module options */
+		split_line(g, pt, 0);
+		return 0;
+	}
+
+	/*
+	 * Last resort: Use "echo".
+	 * DANGER: Applying shell expansion to user supplied input is a
+	 *         major security risk.  Modutils code should only do meta
+	 *         expansion via shell commands for trusted data.  Basically
+	 *         this means only for data in the config file.   Even that
+	 *         assumes that the user cannot run modprobe as root with
+	 *         their own config file.  Programs (including the kernel)
+	 *         that invoke modprobe as root with user supplied input must
+	 *         pass exactly one user supplied parameter and must set
+	 *         safe mode.
+	 */
+	if (!(type & ME_SHELL_COMMAND))
+		return 0;
+	snprintf(wrk, sizeof(wrk), "%s%s", (base_dir ? base_dir : ""), pt);
+	strcpy(tmpline, wrk);	/* safe, same size */
+	snprintf(tmpcmd, sizeof(tmpcmd), "/bin/echo \"");
+	for (p = tmpline, p1 = tmpcmd + strlen(tmpcmd); *p; ++p, ++p1) {
+		if (*p == '"' || *p == '\\')
+			*p1++ = '\\';
+		*p1 = *p;
+	}
+	*p1++ = '"';
+	*p1++ = '\0';
+	if (p1 - tmpcmd > sizeof(tmpcmd)) {
+		error("tmpcmd overflow, should never happen");
+		exit(1);
+	}
+	if ((fin = popen(tmpcmd, "r")) == NULL) {
+		error("Can't execute: %s", tmpcmd);
+		return -1;
+	}
+	/* else */
+
+	/*
+	 * Collect the result
+	 */
+	while (fgets(tmpcmd, PATH_MAX, fin) != NULL) {
+		int l = strlen(tmpcmd);
+
+		line = (char *)xrealloc(line, len + l + 1);
+		line[len] = '\0';
+		strcat(line + len, tmpcmd);	/* safe, realloc */
+		len += l;
+	}
+	pclose(fin);
+
+	if (line) {
+		/* shell used to strip one set of quotes.  Paranoia code in
+		 * 2.3.20 stops that strip so we do it ourselves.
+		 */
+		split_line(g, line, 1);
+		free(line);
+	}
+
+	return 0;
+}
diff -urN linux-2.4.37.11-orig//modutils/modstat.c linux-2.4.37.11-rescue//modutils/modstat.c
--- linux-2.4.37.11-orig//modutils/modstat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/modstat.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,419 @@
+/*
+ * Get kernel symbol table(s) and other relevant module info.
+ *
+ * Add module_name_list and l_module_name_list.
+ *   Keith Owens <kaos@ocs.com.au> November 1999.
+ * Björn Ekwall <bj0rn@blox.se> in February 1999 (C)
+ * Initial work contributed by Richard Henderson <rth@tamu.edu>
+ *
+ * This file is part of the Linux modutils.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include "util.h"
+#include "module.h"
+#include "obj.h"
+#include "modstat.h"
+
+struct module_stat *module_stat;
+size_t n_module_stat;
+char *module_name_list;
+size_t l_module_name_list;
+struct module_symbol *ksyms;
+size_t nksyms;
+int k_new_syscalls;
+
+static void *old_kernsym;
+
+/************************************************************************/
+static void drop(void)
+{
+	/*
+	 * Clean the slate for multiple runs
+	 */
+	if (module_stat) {
+		struct module_stat *m;
+		int i;
+
+		for (i = 0, m = module_stat; i < n_module_stat; ++i, ++m) {
+			if (m->syms)
+				free(m->syms);
+			if (m->refs)
+				free(m->refs);
+		}
+		free(module_stat);
+		module_stat = NULL;
+		n_module_stat = 0;
+	}
+	if (module_name_list) {
+		free(module_name_list);
+		module_name_list = NULL;
+		l_module_name_list = 0;
+	}
+	if (ksyms) {
+		free(ksyms);
+		ksyms = NULL;
+		nksyms = 0;
+	}
+	if (old_kernsym) {
+		free(old_kernsym);
+		old_kernsym = NULL;
+	}
+}
+
+static int new_get_kernel_info(int type)
+{
+	struct module_stat *modules;
+	struct module_stat *m;
+	struct module_symbol *syms;
+	struct module_symbol *s;
+	size_t ret;
+	size_t bufsize;
+	size_t nmod;
+	size_t nsyms;
+	size_t i;
+	size_t j;
+	char *module_names;
+	char *mn;
+
+	drop();
+
+	/*
+	 * Collect the loaded modules
+	 */
+	module_names = xmalloc(bufsize = 256);
+	while (query_module(NULL, QM_MODULES, module_names, bufsize, &ret)) {
+		if (errno != ENOSPC) {
+			error("QM_MODULES: %m\n");
+			return 0;
+		}
+		module_names = xrealloc(module_names, bufsize = ret);
+	}
+	module_name_list = module_names;
+	l_module_name_list = bufsize;
+	n_module_stat = nmod = ret;
+	module_stat = modules = xmalloc(nmod * sizeof(struct module_stat));
+	memset(modules, 0, nmod * sizeof(struct module_stat));
+
+	/* Collect the info from the modules */
+	for (i = 0, mn = module_names, m = modules;
+	     i < nmod;
+	     ++i, ++m, mn += strlen(mn) + 1) {
+		struct module_info info;
+
+		m->name = mn;
+		if (query_module(mn, QM_INFO, &info, sizeof(info), &ret)) {
+			if (errno == ENOENT) {
+			/* The module was removed out from underneath us. */
+				m->flags = NEW_MOD_DELETED;
+				continue;
+			}
+			/* else oops */
+			error("module %s: QM_INFO: %m", mn);
+			return 0;
+		}
+
+		m->addr = info.addr;
+
+		if (type & K_INFO) {
+			m->size = info.size;
+			m->flags = info.flags;
+			m->usecount = info.usecount;
+			m->modstruct = info.addr;
+		}
+
+		if (type & K_REFS) {
+			int mm;
+			char *mrefs;
+			char *mr;
+
+			mrefs = xmalloc(bufsize = 64);
+			while (query_module(mn, QM_REFS, mrefs, bufsize, &ret)) {
+				if (errno != ENOSPC) {
+					error("QM_REFS: %m");
+					return 1;
+				}
+				mrefs = xrealloc(mrefs, bufsize = ret);
+			}
+			for (j = 0, mr = mrefs;
+			     j < ret;
+			     ++j, mr += strlen(mr) + 1) {
+				for (mm = 0; mm < i; ++mm) {
+					if (strcmp(mr, module_stat[mm].name) == 0) {
+						m->nrefs += 1;
+						m->refs = xrealloc(m->refs, m->nrefs * sizeof(struct module_stat **));
+						m->refs[m->nrefs - 1] = module_stat + mm;
+						break;
+					}
+				}
+			}
+			free(mrefs);
+		}
+
+		if (type & K_SYMBOLS) { /* Want info about symbols */
+			syms = xmalloc(bufsize = 1024);
+			while (query_module(mn, QM_SYMBOLS, syms, bufsize, &ret)) {
+				if (errno == ENOSPC) {
+					syms = xrealloc(syms, bufsize = ret);
+					continue;
+				}
+				if (errno == ENOENT) {
+					/*
+					 * The module was removed out
+					 * from underneath us.
+					 */
+					m->flags = NEW_MOD_DELETED;
+					free(syms);
+					goto next;
+				} else {
+					error("module %s: QM_SYMBOLS: %m", mn);
+					return 0;
+				}
+			}
+			nsyms = ret;
+
+			m->nsyms = nsyms;
+			m->syms = syms;
+
+			/* Convert string offsets to string pointers */
+			for (j = 0, s = syms; j < nsyms; ++j, ++s)
+				s->name += (unsigned long) syms;
+		}
+		next: ;
+	}
+
+	if (type & K_SYMBOLS) { /* Want info about symbols */
+		/* Collect the kernel's symbols.  */
+		syms = xmalloc(bufsize = 16 * 1024);
+		while (query_module(NULL, QM_SYMBOLS, syms, bufsize, &ret)) {
+			if (errno != ENOSPC) {
+				error("kernel: QM_SYMBOLS: %m");
+				return 0;
+			}
+			syms = xrealloc(syms, bufsize = ret);
+		}
+		nksyms = nsyms = ret;
+		ksyms = syms;
+
+		/* Convert string offsets to string pointers */
+		for (j = 0, s = syms; j < nsyms; ++j, ++s)
+			s->name += (unsigned long) syms;
+	}
+
+	return 1;
+}
+
+#ifdef COMPAT_2_0
+/************************************************************************/
+
+#define mscan(offs,siz,ptr) \
+	if (lseek(kmem_fd, (off_t)(offs), SEEK_SET) == -1 || \
+	    read(kmem_fd, (ptr), (siz)) != (siz)) { \
+		if (kmem_fd != -1) \
+			close(kmem_fd); \
+		error("kmem: %m"); \
+		return 0; \
+	}
+
+#define OLD_MOD_RUNNING 1
+#define OLD_MOD_DELETED 2
+#define OLD_MOD_VISITED   0x20000000
+
+/* Fetch all the symbols and divvy them up as appropriate for the modules.  */
+static int old_get_kernel_info(int type)
+{
+	struct old_kernel_sym *kernsym;
+	struct old_kernel_sym *k;
+	struct module_stat *module;
+	struct module_stat *mod;
+	struct module_symbol *s = NULL;
+	int kmem_fd = -1;
+	int nkernsym;
+	int nmod;
+	int nm;
+	int nms;
+	int i;
+
+	drop();
+	module_name_list = xmalloc(1);
+	*module_name_list = '\0';
+
+	if ((nkernsym = get_kernel_syms(NULL)) < 0) {
+		error("get_kernel_syms: %m");
+		return 0;
+	}
+	kernsym = k = xmalloc(nkernsym * sizeof(struct old_kernel_sym));
+	old_kernsym = kernsym;
+	if (get_kernel_syms(kernsym) != nkernsym) {
+		error("inconsistency with get_kernel_syms -- is someone else "
+		      "playing with modules?");
+		free(kernsym);
+		return 0;
+	}
+
+	/* Number of modules */
+	for (k = kernsym, nmod = 0, i = 0; i < nkernsym; ++i, ++k) {
+		if (k->name[0] == '#') {
+			if (k->name[1]) {
+				++nmod;
+				i = strlen(k->name+1) + 1;
+				module_name_list =
+					xrealloc(module_name_list,
+					l_module_name_list + i);
+				strcpy(module_name_list+l_module_name_list,	/* safe, xrealloc */
+					k->name+1);
+				l_module_name_list += i;	/* NUL separated strings */
+			}
+			else
+				break;
+		}
+	}
+	module_stat = mod = module = xmalloc(nmod * sizeof(struct module_stat));
+	memset(module, 0, nmod * sizeof(struct module_stat));
+	n_module_stat = nmod;
+
+	/*
+	 * Will we need kernel internal info?
+	 */
+	if ((type & K_INFO) || (type & K_REFS)) {
+		if ((kmem_fd = open("/dev/kmem", O_RDONLY)) < 0) {
+			perror("ksyms: open /dev/kmem");
+			return 0;
+		}
+	}
+
+	/*
+	 * Collect the module information.
+	 */
+	for (k = kernsym, nm = 0, i = 0; i < nkernsym; ++i, ++k) {
+		if (k->name[0] == '#') {
+			struct old_kernel_sym *p;
+			struct old_module info;
+
+			if (k->name[1] == '\0')
+				break; /* kernel resident symbols follow */
+			/* else normal module */
+
+			module = mod++;
+			++nm;
+			module->name = k->name + 1;
+			module->modstruct = k->value;
+
+			if ((type & K_INFO) || (type & K_REFS)) {
+				long tmp;
+				/*
+				 * k->value is the address of the
+				 * struct old_module
+				 * in the kernel (for use via /dev/kmem)
+				 */
+				mscan(k->value, sizeof(info), &info);
+				module->addr = info.addr;
+				module->size = info.size * getpagesize();
+
+				mscan(info.addr, sizeof(long), &tmp);
+				module->flags = info.state &
+						(OLD_MOD_RUNNING | OLD_MOD_DELETED);
+				module->flags |= NEW_MOD_USED_ONCE; /* Cheat */
+				if (tmp & OLD_MOD_AUTOCLEAN)
+					module->flags |= NEW_MOD_AUTOCLEAN;
+				if (tmp & OLD_MOD_VISITED)
+					module->flags |= NEW_MOD_VISITED;
+
+				module->usecount = tmp & ~(OLD_MOD_AUTOCLEAN | OLD_MOD_VISITED);
+			}
+
+			if ((type & K_REFS) && info.ref) {
+				struct old_module_ref mr;
+				int j;
+				unsigned long ref = info.ref;
+
+				do {
+					mscan(ref, sizeof(struct old_module_ref), &mr);
+					for (j = 0; j < nm -1; ++j) {
+						if (mr.module == module_stat[j].modstruct) {
+							module->nrefs += 1;
+							module->refs = xrealloc(module->refs, module->nrefs * sizeof(struct module_stat **));
+							module->refs[module->nrefs - 1] = module_stat + j;
+							break;
+						}
+					}
+				} while ((ref = mr.next) != 0);
+			}
+
+			if (!(type & K_SYMBOLS))
+				continue;
+			/*
+			 * Find out how many symbols this module has.
+			 */
+			for (nms = 0, p = k+1; p->name[0] != '#'; ++p)
+				++nms;
+			s = xmalloc(nms * sizeof(struct module_symbol));
+			module->syms = s;
+			module->nsyms = nms;
+		} else if (type & K_SYMBOLS) { /* Want info about symbols */
+			s->name = (unsigned long) k->name;
+			s->value = k->value;
+			++s;
+		}
+	}
+	if ((type & K_INFO) || (type & K_REFS)) {
+		if (kmem_fd != -1)
+			close(kmem_fd);
+	}
+
+	/*
+	 * Kernel resident symbols follows
+	 */
+	if (type & K_SYMBOLS) { /* Want info about symbols */
+		if (k->name[0] == '#')
+			++k;
+		nksyms = nkernsym - (k - kernsym);
+		if (nksyms) {
+			ksyms = s = xmalloc(nksyms * sizeof(struct module_symbol));
+			for (i = 0; i < nksyms; ++i, ++k) {
+				if (k->name[0] != '#') {
+					s->name = (unsigned long) k->name;
+					s->value = k->value;
+					++s;
+				}
+			}
+			nksyms = s - ksyms;
+		} else
+			ksyms = NULL;
+	}
+
+	return 1;
+}
+#endif /* COMPAT_2_0 */
+
+int get_kernel_info(int type)
+{
+	k_new_syscalls = !query_module(NULL, 0, NULL, 0, NULL);
+
+#ifdef COMPAT_2_0
+	if (!k_new_syscalls)
+		return old_get_kernel_info(type);
+#endif /* COMPAT_2_0 */
+
+	return new_get_kernel_info(type);
+}
diff -urN linux-2.4.37.11-orig//modutils/modstat.h linux-2.4.37.11-rescue//modutils/modstat.h
--- linux-2.4.37.11-orig//modutils/modstat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/modstat.h	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,55 @@
+/*
+ * For kernel module status and information
+ *
+ * Add module_name_list and l_module_name_list.
+ *   Keith Owens <kaos@ocs.com.au> November 1999.
+ * Björn Ekwall <bj0rn@blox.se> February 1999.
+ *
+ * This file is part of the Linux modutils.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef _KERNEL_H
+#define _KERNEL_H
+
+#define K_SYMBOLS 1 /* Want info about symbols */
+#define K_INFO 2 /* Want extended module info */
+#define K_REFS 4 /* Want info about references */
+
+struct module_stat {
+	char *name;
+	unsigned long addr;
+	unsigned long modstruct; /* COMPAT_2_0! *//* depends on architecture? */
+	unsigned long size;
+	unsigned long flags;
+	long usecount;
+	size_t nsyms;
+	struct module_symbol *syms;
+	size_t nrefs;
+	struct module_stat **refs;
+	unsigned long status;
+};
+
+extern struct module_stat *module_stat;
+extern size_t n_module_stat;
+extern char *module_name_list;
+extern size_t l_module_name_list;
+extern struct module_symbol *ksyms;
+extern size_t nksyms;
+extern int k_new_syscalls;
+
+int get_kernel_info(int type);
+
+#endif /* _KERNEL_H */
diff -urN linux-2.4.37.11-orig//modutils/module.h linux-2.4.37.11-rescue//modutils/module.h
--- linux-2.4.37.11-orig//modutils/module.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/module.h	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,220 @@
+#ifndef MODUTILS_MODULE_H
+#define MODUTILS_MODULE_H 1
+
+/* Definitions for the Linux module syscall interface.
+   Copyright 1996, 1997 Linux International.
+
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+/* This file contains the structures used by the 2.0 and 2.1 kernels.
+   We do not use the kernel headers directly because we do not wish
+   to be dependant on a particular kernel version to compile insmod.  */
+
+
+/*======================================================================*/
+/* The structures used by Linux 2.0.  */
+
+/* The symbol format used by get_kernel_syms(2).  */
+struct old_kernel_sym
+{
+  unsigned long value;
+  char name[60];
+};
+
+struct old_module_ref
+{
+  unsigned long module;		/* kernel addresses */
+  unsigned long next;
+};
+
+struct old_module_symbol
+{
+  unsigned long addr;
+  unsigned long name;
+};
+
+struct old_symbol_table
+{
+  int size;			/* total, including string table!!! */
+  int n_symbols;
+  int n_refs;
+  struct old_module_symbol symbol[0]; /* actual size defined by n_symbols */
+  struct old_module_ref ref[0];	/* actual size defined by n_refs */
+};
+
+struct old_mod_routines
+{
+  unsigned long init;
+  unsigned long cleanup;
+};
+
+struct old_module
+{
+  unsigned long next;
+  unsigned long ref;		/* the list of modules that refer to me */
+  unsigned long symtab;
+  unsigned long name;
+  int size;			/* size of module in pages */
+  unsigned long addr;		/* address of module */
+  int state;
+  unsigned long cleanup;	/* cleanup routine */
+};
+
+/* Sent to init_module(2) or'ed into the code size parameter.  */
+#define OLD_MOD_AUTOCLEAN 0x40000000 /* big enough, but no sign problems... */
+
+int get_kernel_syms(struct old_kernel_sym *);
+int old_sys_init_module(const char *name, char *code, unsigned codesize,
+			struct old_mod_routines *, struct old_symbol_table *);
+
+/*======================================================================*/
+/* For sizeof() which are related to the module platform and not to the
+   environment isnmod is running in, use sizeof_xx instead of sizeof(xx).  */
+
+#define tgt_sizeof_char		sizeof(char)
+#define tgt_sizeof_short	sizeof(short)
+#define tgt_sizeof_int		sizeof(int)
+#define tgt_sizeof_long		sizeof(long)
+#define tgt_sizeof_char_p	sizeof(char *)
+#define tgt_sizeof_void_p	sizeof(void *)
+#define tgt_long		long
+#define tgt_long_fmt		"l"
+#define tgt_strtoul		strtoul
+
+/* This assumes that long long on a 32 bit system is equivalent to long on the
+ * equivalent 64 bit system.  Also that void and char pointers are 8 bytes on
+ * all 64 bit systems.  Add per system tweaks if it ever becomes necessary.
+ */
+#if defined(COMMON_3264) && defined(ONLY_64)
+#undef tgt_long
+#undef tgt_long_fmt
+#undef tgt_sizeof_long
+#undef tgt_sizeof_char_p
+#undef tgt_sizeof_void_p
+#undef tgt_strtoul
+#define tgt_long                long long
+#define tgt_long_fmt		"ll"
+#define tgt_sizeof_long         8
+#define tgt_sizeof_char_p       8
+#define tgt_sizeof_void_p       8
+#define tgt_strtoul             strtoull
+#endif
+
+/*======================================================================*/
+/* The structures used in Linux 2.1 onwards.  */
+
+/* Note: module_symbol does not use tgt_long intentionally */
+struct module_symbol
+{
+  unsigned long value;
+  unsigned long name;
+};
+
+struct module_ref
+{
+  unsigned tgt_long dep;		/* kernel addresses */
+  unsigned tgt_long ref;
+  unsigned tgt_long next_ref;
+};
+
+struct module
+{
+  unsigned tgt_long size_of_struct;	/* == sizeof(module) */
+  unsigned tgt_long next;
+  unsigned tgt_long name;
+  unsigned tgt_long size;
+
+  tgt_long usecount;
+  unsigned tgt_long flags;		/* AUTOCLEAN et al */
+
+  unsigned nsyms;
+  unsigned ndeps;
+
+  unsigned tgt_long syms;
+  unsigned tgt_long deps;
+  unsigned tgt_long refs;
+  unsigned tgt_long init;
+  unsigned tgt_long cleanup;
+  unsigned tgt_long ex_table_start;
+  unsigned tgt_long ex_table_end;
+#ifdef __alpha__
+  unsigned tgt_long gp;
+#endif
+  /* Everything after here is extension.  */
+  unsigned tgt_long read_start;		/* Read data from existing module */
+  unsigned tgt_long read_end;
+  unsigned tgt_long can_unload;
+  unsigned tgt_long runsize;
+  unsigned tgt_long kallsyms_start;
+  unsigned tgt_long kallsyms_end;
+  unsigned tgt_long archdata_start;
+  unsigned tgt_long archdata_end;
+  unsigned tgt_long kernel_data;
+};
+
+struct module_info
+{
+  unsigned long addr;
+  unsigned long size;
+  unsigned long flags;
+	   long usecount;
+};
+
+/* Bits of module.flags.  */
+#define NEW_MOD_RUNNING		1
+#define NEW_MOD_DELETED		2
+#define NEW_MOD_AUTOCLEAN	4
+#define NEW_MOD_VISITED		8
+#define NEW_MOD_USED_ONCE	16
+#define NEW_MOD_INITIALIZING	64
+
+int sys_init_module(const char *name, const struct module *);
+int query_module(const char *name, int which, void *buf, size_t bufsize,
+		 size_t *ret);
+
+/* Values for query_module's which.  */
+
+#define QM_MODULES	1
+#define QM_DEPS		2
+#define QM_REFS		3
+#define QM_SYMBOLS	4
+#define QM_INFO		5
+
+/*======================================================================*/
+/* The system calls unchanged between 2.0 and 2.1.  */
+
+unsigned long create_module(const char *, size_t);
+int delete_module(const char *);
+
+/* In safe mode the last parameter is forced to be a module name and meta
+ * expansion is not allowed on that name.
+ */
+extern unsigned int safemode;
+
+/*======================================================================*/
+/* Tainted kernel information.  This must match include/linux/kernel.h  */
+/* and kernel/panic.c.                                                  */
+
+#define TAINT_FILENAME			"/proc/sys/kernel/tainted"
+#define TAINT_PROPRIETORY_MODULE	(1<<0)
+#define TAINT_FORCED_MODULE		(1<<1)
+#define TAINT_UNSAFE_SMP		(1<<2)
+
+#endif /* module.h */
diff -urN linux-2.4.37.11-orig//modutils/obj.h linux-2.4.37.11-rescue//modutils/obj.h
--- linux-2.4.37.11-orig//modutils/obj.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/obj.h	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,302 @@
+#ifndef MODUTILS_OBJ_H
+#define MODUTILS_OBJ_H 1
+
+/* Elf object file loading and relocation routines.
+   Copyright 1996, 1997 Linux International.
+
+   Contributed by Richard Henderson <rth@tamu.edu>
+   obj_free() added by Björn Ekwall <bj0rn@blox.se> March 1999
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+/* The relocatable object is manipulated using elfin types.  */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <elf.h>
+#include ELF_MACHINE_H
+#include "module.h"
+
+#ifndef ElfW
+# if ELFCLASSM == ELFCLASS32
+#  define ElfW(x)  Elf32_ ## x
+#  define ELFW(x)  ELF32_ ## x
+# else
+#  define ElfW(x)  Elf64_ ## x
+#  define ELFW(x)  ELF64_ ## x
+# endif
+#endif
+
+#if defined(COMMON_3264) && defined(ONLY_32)
+#  define ObjW(x)  obj32_ ## x
+#else
+#  if defined(COMMON_3264) && defined(ONLY_64)
+#    define ObjW(x)  obj64_ ## x
+#  else
+#    define ObjW(x)    obj_ ## x
+#  endif
+#endif
+
+/* For some reason this is missing from lib5.  */
+#ifndef ELF32_ST_INFO
+# define ELF32_ST_INFO(bind, type)       (((bind) << 4) + ((type) & 0xf))
+#endif
+
+#ifndef ELF64_ST_INFO
+# define ELF64_ST_INFO(bind, type)       (((bind) << 4) + ((type) & 0xf))
+#endif
+
+struct obj_string_patch_struct;
+struct obj_symbol_patch_struct;
+
+struct obj_section
+{
+  ElfW(Shdr) header;
+  const char *name;
+  char *contents;
+  struct obj_section *load_next;
+  int idx;
+};
+
+struct obj_symbol
+{
+  struct obj_symbol *next;	/* hash table link */
+  const char *name;
+  tgt_long value;
+  unsigned long size;
+  int secidx;			/* the defining section index/module */
+  int info;
+  int ksymidx;			/* for export to the kernel symtab */
+  int r_type;			/* relocation type */
+};
+
+/* Hardcode the hash table size.  We shouldn't be needing so many
+   symbols that we begin to degrade performance, and we get a big win
+   by giving the compiler a constant divisor.  */
+
+#define HASH_BUCKETS  521
+
+struct obj_file
+{
+  ElfW(Ehdr) header;
+  ElfW(Addr) baseaddr;
+  struct obj_section **sections;
+  struct obj_section *load_order;
+  struct obj_section **load_order_search_start;
+  struct obj_string_patch_struct *string_patches;
+  struct obj_symbol_patch_struct *symbol_patches;
+  int (*symbol_cmp)(const char *, const char *);
+  unsigned long (*symbol_hash)(const char *);
+  unsigned long local_symtab_size;
+  struct obj_symbol **local_symtab;
+  struct obj_symbol *symtab[HASH_BUCKETS];
+  const char *filename;
+  char *persist;
+};
+
+enum obj_reloc
+{
+  obj_reloc_ok,
+  obj_reloc_overflow,
+  obj_reloc_dangerous,
+  obj_reloc_unhandled,
+  obj_reloc_constant_gp
+};
+
+struct obj_string_patch_struct
+{
+  struct obj_string_patch_struct *next;
+  int reloc_secidx;
+  ElfW(Addr) reloc_offset;
+  ElfW(Addr) string_offset;
+};
+
+struct obj_symbol_patch_struct
+{
+  struct obj_symbol_patch_struct *next;
+  int reloc_secidx;
+  ElfW(Addr) reloc_offset;
+  struct obj_symbol *sym;
+};
+
+
+/* Generic object manipulation routines.  */
+
+#define obj_elf_hash			ObjW(elf_hash)
+#define obj_elf_hash_n			ObjW(elf_hash_n)
+#define obj_add_symbol			ObjW(add_symbol)
+#define obj_find_symbol			ObjW(find_symbol)
+#define obj_symbol_final_value		ObjW(symbol_final_value)
+#define obj_set_symbol_compare		ObjW(set_symbol_compare)
+#define obj_find_section		ObjW(find_section)
+#define obj_insert_section_load_order	ObjW(insert_section_load_order)
+#define obj_create_alloced_section	ObjW(create_alloced_section)
+#define obj_create_alloced_section_first \
+					ObjW(create_alloced_section_first)
+#define obj_extend_section		ObjW(extend_section)
+#define obj_string_patch		ObjW(string_patch)
+#define obj_symbol_patch		ObjW(symbol_patch)
+#define obj_check_undefineds		ObjW(check_undefineds)
+#define obj_clear_undefineds		ObjW(clear_undefineds)
+#define obj_allocate_commons		ObjW(allocate_commons)
+#define obj_load_size			ObjW(load_size)
+#define obj_relocate			ObjW(relocate)
+#define obj_load			ObjW(load)
+#define obj_free			ObjW(free)
+#define obj_create_image		ObjW(create_image)
+#define obj_addr_to_native_ptr		ObjW(addr_to_native_ptr)
+#define obj_native_ptr_to_addr		ObjW(native_ptr_to_addr)
+#define obj_kallsyms			ObjW(kallsyms)
+#define obj_gpl_license			ObjW(gpl_license)
+#define arch_new_file			ObjW(arch_new_file)
+#define arch_new_section		ObjW(arch_new_section)
+#define arch_new_symbol			ObjW(arch_new_symbol)
+#define arch_apply_relocation		ObjW(arch_apply_relocation)
+#define arch_create_got			ObjW(arch_create_got)
+#define arch_init_module		ObjW(arch_init_module)
+#define arch_load_proc_section		ObjW(arch_load_proc_section)
+#define arch_finalize_section_address	ObjW(arch_finalize_section_address)
+#define arch_archdata			ObjW(arch_archdata)
+
+unsigned long obj_elf_hash (const char *);
+
+unsigned long obj_elf_hash_n (const char *, unsigned long len);
+
+struct obj_symbol *obj_add_symbol (struct obj_file *f, const char *name,
+				   unsigned long symidx, int info, int secidx,
+				   ElfW(Addr) value, unsigned long size);
+
+struct obj_symbol *obj_find_symbol (struct obj_file *f,
+					 const char *name);
+
+ElfW(Addr) obj_symbol_final_value (struct obj_file *f,
+				  struct obj_symbol *sym);
+
+void obj_set_symbol_compare (struct obj_file *f,
+			    int (*cmp)(const char *, const char *),
+			    unsigned long (*hash)(const char *));
+
+struct obj_section *obj_find_section (struct obj_file *f,
+					   const char *name);
+
+void obj_insert_section_load_order (struct obj_file *f,
+				    struct obj_section *sec);
+
+struct obj_section *obj_create_alloced_section (struct obj_file *f,
+						const char *name,
+						unsigned long align,
+						unsigned long size,
+						unsigned long flags);
+
+struct obj_section *obj_create_alloced_section_first (struct obj_file *f,
+						      const char *name,
+						      unsigned long align,
+						      unsigned long size);
+
+void *obj_extend_section (struct obj_section *sec, unsigned long more);
+
+int obj_string_patch (struct obj_file *f, int secidx, ElfW(Addr) offset,
+		     const char *string);
+
+int obj_symbol_patch (struct obj_file *f, int secidx, ElfW(Addr) offset,
+		     struct obj_symbol *sym);
+
+int obj_check_undefineds (struct obj_file *f, int quiet);
+
+void obj_clear_undefineds (struct obj_file *f);
+
+void obj_allocate_commons (struct obj_file *f);
+
+unsigned long obj_load_size (struct obj_file *f);
+
+int obj_relocate (struct obj_file *f, ElfW(Addr) base);
+
+struct obj_file *obj_load (int f, Elf32_Half e_type, const char *filename);
+
+void obj_free (struct obj_file *f);
+
+int obj_create_image (struct obj_file *f, char *image);
+
+int obj_kallsyms (struct obj_file *fin, struct obj_file **fout);
+
+/* Architecture specific manipulation routines.  */
+
+struct obj_file *arch_new_file (void);
+
+struct obj_section *arch_new_section (void);
+
+struct obj_symbol *arch_new_symbol (void);
+
+enum obj_reloc arch_apply_relocation (struct obj_file *f,
+				      struct obj_section *targsec,
+				      struct obj_section *symsec,
+				      struct obj_symbol *sym,
+				      ElfW(RelM) *rel, ElfW(Addr) value);
+
+int arch_create_got (struct obj_file *f);
+
+struct module;
+int arch_init_module (struct obj_file *f, struct module *);
+
+int arch_load_proc_section (struct obj_section *sec, int fp);
+
+int arch_finalize_section_address (struct obj_file *f, ElfW(Addr) base);
+
+int arch_archdata (struct obj_file *fin, struct obj_section *sec);
+
+#ifndef arch_module_base
+#define arch_module_base(m) ((ElfW(Addr))0)
+#endif
+
+#define ARCHDATA_SEC_NAME "__archdata"
+
+/* Pointers in objects can be 32 or 64 bit */
+union obj_ptr_4 {
+	Elf32_Word addr;
+	void *ptr;
+};
+union obj_ptr_8 {
+	u_int64_t addr;	/* Should be Elf64_Xword but not all users have this yet */
+	void *ptr;
+};
+
+void *obj_addr_to_native_ptr(ElfW(Addr));
+
+ElfW(Addr) obj_native_ptr_to_addr(void *);
+
+/* Standard method of finding relocation symbols, sets isym */
+#define obj_find_relsym(isym, f, find, rel, symtab, strtab) \
+	{ \
+		unsigned long symndx = ELFW(R_SYM)((rel)->r_info); \
+		ElfW(Sym) *extsym = (symtab)+symndx; \
+		if (ELFW(ST_BIND)(extsym->st_info) == STB_LOCAL) { \
+			isym = (typeof(isym)) (f)->local_symtab[symndx]; \
+		} \
+		else { \
+			const char *name; \
+			if (extsym->st_name) \
+				name = (strtab) + extsym->st_name; \
+			else \
+				name = (f)->sections[extsym->st_shndx]->name; \
+			isym = (typeof(isym)) obj_find_symbol((find), name); \
+		} \
+	}
+
+int obj_gpl_license(struct obj_file *, const char **);
+
+#endif /* obj.h */
diff -urN linux-2.4.37.11-orig//modutils/parse.c linux-2.4.37.11-rescue//modutils/parse.c
--- linux-2.4.37.11-orig//modutils/parse.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/parse.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,2321 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     FLOAT_KEYW = 267,
+     INLINE_KEYW = 268,
+     INT_KEYW = 269,
+     LONG_KEYW = 270,
+     REGISTER_KEYW = 271,
+     RESTRICT_KEYW = 272,
+     SHORT_KEYW = 273,
+     SIGNED_KEYW = 274,
+     STATIC_KEYW = 275,
+     STRUCT_KEYW = 276,
+     TYPEDEF_KEYW = 277,
+     UNION_KEYW = 278,
+     UNSIGNED_KEYW = 279,
+     VOID_KEYW = 280,
+     VOLATILE_KEYW = 281,
+     EXPORT_SYMBOL_KEYW = 282,
+     ASM_PHRASE = 283,
+     ATTRIBUTE_PHRASE = 284,
+     BRACE_PHRASE = 285,
+     BRACKET_PHRASE = 286,
+     EXPRESSION_PHRASE = 287,
+     CHAR = 288,
+     DOTS = 289,
+     IDENT = 290,
+     INT = 291,
+     REAL = 292,
+     STRING = 293,
+     TYPE = 294,
+     OTHER = 295,
+     FILENAME = 296
+   };
+#endif
+/* Tokens.  */
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define FLOAT_KEYW 267
+#define INLINE_KEYW 268
+#define INT_KEYW 269
+#define LONG_KEYW 270
+#define REGISTER_KEYW 271
+#define RESTRICT_KEYW 272
+#define SHORT_KEYW 273
+#define SIGNED_KEYW 274
+#define STATIC_KEYW 275
+#define STRUCT_KEYW 276
+#define TYPEDEF_KEYW 277
+#define UNION_KEYW 278
+#define UNSIGNED_KEYW 279
+#define VOID_KEYW 280
+#define VOLATILE_KEYW 281
+#define EXPORT_SYMBOL_KEYW 282
+#define ASM_PHRASE 283
+#define ATTRIBUTE_PHRASE 284
+#define BRACE_PHRASE 285
+#define BRACKET_PHRASE 286
+#define EXPRESSION_PHRASE 287
+#define CHAR 288
+#define DOTS 289
+#define IDENT 290
+#define INT 291
+#define REAL 292
+#define STRING 293
+#define TYPE 294
+#define OTHER 295
+#define FILENAME 296
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 24 "parse.y"
+
+
+#include <assert.h>
+#include "genksyms.h"
+
+static int is_typedef;
+static int is_extern;
+static char *current_name;
+static struct string_list *decl_spec;
+
+static void yyerror(const char *);
+
+static inline void
+remove_node(struct string_list **p)
+{
+  struct string_list *node = *p;
+  *p = node->next;
+  free_node(node);
+}
+
+static inline void
+remove_list(struct string_list **pb, struct string_list **pe)
+{
+  struct string_list *b = *pb, *e = *pe;
+  *pb = e;
+  free_list(b, e);
+}
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 218 "parse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  4
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   455
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  51
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  45
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  122
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  168
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   296
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      46,    47,    45,     2,    44,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    50,    42,
+       2,    48,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    49,     2,    43,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     8,     9,    12,    13,    17,    19,
+      21,    23,    25,    28,    31,    35,    36,    38,    40,    44,
+      49,    50,    52,    54,    57,    59,    61,    63,    65,    67,
+      69,    71,    73,    75,    78,    81,    84,    88,    92,    96,
+      99,   102,   105,   107,   109,   111,   113,   115,   117,   119,
+     121,   123,   125,   127,   130,   131,   133,   135,   138,   140,
+     142,   144,   146,   149,   151,   153,   158,   163,   166,   170,
+     174,   177,   179,   181,   183,   188,   193,   196,   200,   204,
+     207,   209,   213,   214,   216,   218,   222,   225,   228,   230,
+     231,   233,   235,   240,   245,   248,   252,   256,   260,   261,
+     263,   266,   270,   274,   275,   277,   279,   282,   286,   289,
+     290,   292,   294,   298,   301,   304,   306,   309,   310,   312,
+     315,   316,   318
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      52,     0,    -1,    53,    -1,    52,    53,    -1,    -1,    54,
+      55,    -1,    -1,    22,    56,    57,    -1,    57,    -1,    81,
+      -1,    93,    -1,    95,    -1,     1,    42,    -1,     1,    43,
+      -1,    61,    58,    42,    -1,    -1,    59,    -1,    60,    -1,
+      59,    44,    60,    -1,    71,    94,    92,    82,    -1,    -1,
+      62,    -1,    63,    -1,    62,    63,    -1,    64,    -1,    65,
+      -1,     5,    -1,    16,    -1,    20,    -1,    11,    -1,    13,
+      -1,    66,    -1,    70,    -1,    21,    35,    -1,    23,    35,
+      -1,    10,    35,    -1,    21,    35,    84,    -1,    23,    35,
+      84,    -1,    10,    35,    30,    -1,    10,    30,    -1,    21,
+      84,    -1,    23,    84,    -1,     7,    -1,    18,    -1,    14,
+      -1,    15,    -1,    19,    -1,    24,    -1,    12,    -1,     9,
+      -1,    25,    -1,     6,    -1,    39,    -1,    45,    68,    -1,
+      -1,    69,    -1,    70,    -1,    69,    70,    -1,     8,    -1,
+      26,    -1,    29,    -1,    17,    -1,    67,    71,    -1,    72,
+      -1,    35,    -1,    72,    46,    75,    47,    -1,    72,    46,
+       1,    47,    -1,    72,    31,    -1,    46,    71,    47,    -1,
+      46,     1,    47,    -1,    67,    73,    -1,    74,    -1,    35,
+      -1,    39,    -1,    74,    46,    75,    47,    -1,    74,    46,
+       1,    47,    -1,    74,    31,    -1,    46,    73,    47,    -1,
+      46,     1,    47,    -1,    76,    34,    -1,    76,    -1,    77,
+      44,    34,    -1,    -1,    77,    -1,    78,    -1,    77,    44,
+      78,    -1,    62,    79,    -1,    67,    79,    -1,    80,    -1,
+      -1,    35,    -1,    39,    -1,    80,    46,    75,    47,    -1,
+      80,    46,     1,    47,    -1,    80,    31,    -1,    46,    79,
+      47,    -1,    46,     1,    47,    -1,    61,    71,    30,    -1,
+      -1,    83,    -1,    48,    32,    -1,    49,    85,    43,    -1,
+      49,     1,    43,    -1,    -1,    86,    -1,    87,    -1,    86,
+      87,    -1,    61,    88,    42,    -1,     1,    42,    -1,    -1,
+      89,    -1,    90,    -1,    89,    44,    90,    -1,    73,    92,
+      -1,    35,    91,    -1,    91,    -1,    50,    32,    -1,    -1,
+      29,    -1,    28,    42,    -1,    -1,    28,    -1,    27,    46,
+      35,    47,    42,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   100,   100,   101,   105,   105,   111,   111,   113,   114,
+     115,   116,   117,   118,   122,   136,   137,   141,   149,   162,
+     168,   169,   173,   174,   178,   185,   189,   190,   191,   192,
+     193,   197,   198,   202,   204,   206,   210,   217,   224,   233,
+     234,   235,   239,   240,   241,   242,   243,   244,   245,   246,
+     247,   248,   249,   253,   258,   259,   263,   264,   268,   268,
+     268,   269,   277,   278,   282,   291,   293,   295,   297,   299,
+     306,   307,   311,   312,   313,   315,   317,   319,   321,   326,
+     327,   328,   332,   333,   337,   338,   343,   348,   350,   354,
+     355,   364,   369,   371,   373,   375,   377,   382,   391,   392,
+     397,   402,   403,   407,   408,   412,   413,   417,   419,   424,
+     425,   429,   430,   434,   435,   436,   440,   444,   445,   449,
+     453,   454,   458
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "ASM_KEYW", "ATTRIBUTE_KEYW",
+  "AUTO_KEYW", "BOOL_KEYW", "CHAR_KEYW", "CONST_KEYW", "DOUBLE_KEYW",
+  "ENUM_KEYW", "EXTERN_KEYW", "FLOAT_KEYW", "INLINE_KEYW", "INT_KEYW",
+  "LONG_KEYW", "REGISTER_KEYW", "RESTRICT_KEYW", "SHORT_KEYW",
+  "SIGNED_KEYW", "STATIC_KEYW", "STRUCT_KEYW", "TYPEDEF_KEYW",
+  "UNION_KEYW", "UNSIGNED_KEYW", "VOID_KEYW", "VOLATILE_KEYW",
+  "EXPORT_SYMBOL_KEYW", "ASM_PHRASE", "ATTRIBUTE_PHRASE", "BRACE_PHRASE",
+  "BRACKET_PHRASE", "EXPRESSION_PHRASE", "CHAR", "DOTS", "IDENT", "INT",
+  "REAL", "STRING", "TYPE", "OTHER", "FILENAME", "';'", "'}'", "','",
+  "'*'", "'('", "')'", "'='", "'{'", "':'", "$accept", "declaration_seq",
+  "declaration", "@1", "declaration1", "@2", "simple_declaration",
+  "init_declarator_list_opt", "init_declarator_list", "init_declarator",
+  "decl_specifier_seq_opt", "decl_specifier_seq", "decl_specifier",
+  "storage_class_specifier", "type_specifier", "simple_type_specifier",
+  "ptr_operator", "cvar_qualifier_seq_opt", "cvar_qualifier_seq",
+  "cvar_qualifier", "declarator", "direct_declarator", "nested_declarator",
+  "direct_nested_declarator", "parameter_declaration_clause",
+  "parameter_declaration_list_opt", "parameter_declaration_list",
+  "parameter_declaration", "m_abstract_declarator",
+  "direct_m_abstract_declarator", "function_definition", "initializer_opt",
+  "initializer", "class_body", "member_specification_opt",
+  "member_specification", "member_declaration",
+  "member_declarator_list_opt", "member_declarator_list",
+  "member_declarator", "member_bitfield_declarator", "attribute_opt",
+  "asm_definition", "asm_phrase_opt", "export_definition", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,    59,   125,    44,    42,    40,    41,    61,   123,
+      58
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    51,    52,    52,    54,    53,    56,    55,    55,    55,
+      55,    55,    55,    55,    57,    58,    58,    59,    59,    60,
+      61,    61,    62,    62,    63,    63,    64,    64,    64,    64,
+      64,    65,    65,    65,    65,    65,    65,    65,    65,    65,
+      65,    65,    66,    66,    66,    66,    66,    66,    66,    66,
+      66,    66,    66,    67,    68,    68,    69,    69,    70,    70,
+      70,    70,    71,    71,    72,    72,    72,    72,    72,    72,
+      73,    73,    74,    74,    74,    74,    74,    74,    74,    75,
+      75,    75,    76,    76,    77,    77,    78,    79,    79,    80,
+      80,    80,    80,    80,    80,    80,    80,    81,    82,    82,
+      83,    84,    84,    85,    85,    86,    86,    87,    87,    88,
+      88,    89,    89,    90,    90,    90,    91,    92,    92,    93,
+      94,    94,    95
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     2,     0,     2,     0,     3,     1,     1,
+       1,     1,     2,     2,     3,     0,     1,     1,     3,     4,
+       0,     1,     1,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     2,     2,     2,     3,     3,     3,     2,
+       2,     2,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     2,     0,     1,     1,     2,     1,     1,
+       1,     1,     2,     1,     1,     4,     4,     2,     3,     3,
+       2,     1,     1,     1,     4,     4,     2,     3,     3,     2,
+       1,     3,     0,     1,     1,     3,     2,     2,     1,     0,
+       1,     1,     4,     4,     2,     3,     3,     3,     0,     1,
+       2,     3,     3,     0,     1,     1,     2,     3,     2,     0,
+       1,     1,     3,     2,     2,     1,     2,     0,     1,     2,
+       0,     1,     5
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       4,     4,     2,     0,     1,     3,     0,    26,    51,    42,
+      58,    49,     0,    29,    48,    30,    44,    45,    27,    61,
+      43,    46,    28,     0,     6,     0,    47,    50,    59,     0,
+       0,    60,    52,     5,     8,    15,    21,    22,    24,    25,
+      31,    32,     9,    10,    11,    12,    13,    39,    35,    33,
+       0,    40,    20,    34,    41,     0,   119,    64,    54,     0,
+       0,    16,    17,     0,   120,    63,    23,    38,    36,     0,
+     109,     0,     0,   105,     7,    15,    37,     0,    53,    55,
+      56,     0,     0,    14,     0,    62,   121,    97,   117,    67,
+       0,   108,   102,    72,    73,     0,     0,     0,   117,    71,
+       0,   110,   111,   115,   101,     0,   106,   120,     0,    57,
+      69,    68,    18,   118,    98,     0,    89,     0,    80,    83,
+      84,   114,     0,    72,     0,   116,    70,   113,    76,     0,
+     107,     0,   122,     0,    19,    99,    66,    90,    52,     0,
+      89,    86,    88,    65,    79,     0,    78,    77,     0,     0,
+     112,   100,     0,    91,     0,    87,    94,     0,    81,    85,
+      75,    74,    96,    95,     0,     0,    93,    92
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,     2,     3,    33,    52,    34,    60,    61,    62,
+      70,    36,    37,    38,    39,    40,    63,    78,    79,    41,
+     107,    65,    98,    99,   117,   118,   119,   120,   141,   142,
+      42,   134,   135,    51,    71,    72,    73,   100,   101,   102,
+     103,   114,    43,    88,    44
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -122
+static const yytype_int16 yypact[] =
+{
+    -122,    16,  -122,   297,  -122,  -122,     1,  -122,  -122,  -122,
+    -122,  -122,   -17,  -122,  -122,  -122,  -122,  -122,  -122,  -122,
+    -122,  -122,  -122,     4,  -122,    11,  -122,  -122,  -122,   -23,
+       9,  -122,  -122,  -122,  -122,    63,   416,  -122,  -122,  -122,
+    -122,  -122,  -122,  -122,  -122,  -122,  -122,  -122,    29,    12,
+      76,  -122,   416,    12,  -122,     5,  -122,  -122,    -2,    10,
+      24,    35,  -122,    63,   -16,   -21,  -122,  -122,  -122,    33,
+      28,    25,   122,  -122,  -122,    63,  -122,    57,  -122,    -2,
+    -122,    65,    73,  -122,    63,  -122,  -122,  -122,    43,  -122,
+     168,  -122,  -122,    94,  -122,    19,   117,    68,    43,   -14,
+     108,   109,  -122,  -122,  -122,   110,  -122,   126,   113,  -122,
+    -122,  -122,  -122,  -122,   111,   115,   339,   116,   124,   112,
+    -122,  -122,   119,  -122,   123,  -122,  -122,  -122,  -122,   211,
+    -122,    28,  -122,   128,  -122,  -122,  -122,  -122,  -122,     3,
+      71,  -122,    -9,  -122,  -122,   381,  -122,  -122,   143,   148,
+    -122,  -122,   149,  -122,   151,  -122,  -122,   254,  -122,  -122,
+    -122,  -122,  -122,  -122,   152,   153,  -122,  -122
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -122,  -122,   170,  -122,  -122,  -122,   154,  -122,  -122,   120,
+       0,   -88,   -36,  -122,  -122,  -122,   -69,  -122,  -122,   -49,
+     -30,  -122,   -76,  -122,  -121,  -122,  -122,    56,   -15,  -122,
+    -122,  -122,  -122,   -18,  -122,  -122,   131,  -122,  -122,    74,
+     118,   135,  -122,  -122,  -122
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -105
+static const yytype_int16 yytable[] =
+{
+      66,    97,   116,    35,   152,    64,    10,    54,   149,    80,
+      89,    81,    86,    47,    87,    19,     4,   128,    48,   124,
+     122,   126,   156,    55,    28,    90,    97,    31,    97,    82,
+     109,    68,   129,    85,   -89,    76,   165,   157,   137,    49,
+      77,   116,   153,    45,    46,    57,    53,   140,    58,   139,
+     -89,    56,    75,    50,   123,    58,    59,   116,    94,    67,
+      50,    50,    97,    93,    58,    95,    83,    94,   104,   116,
+     140,   140,   113,    58,    95,    91,    92,    69,    96,    84,
+      66,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    57,    25,
+      26,    27,    28,   123,   108,    31,   137,    94,    58,    59,
+     153,   -20,   110,    58,    95,    32,    58,   139,   -20,  -103,
+     111,   -20,   -20,   105,   154,   155,   -20,     7,     8,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    96,    25,    26,    27,    28,   125,
+     130,    31,    91,   131,    86,   132,   145,   -20,   144,   133,
+     151,    32,   136,   143,   -20,  -104,   146,   -20,   -20,   115,
+     147,     5,   -20,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
+     160,    25,    26,    27,    28,   161,   162,    31,   163,   166,
+     167,   159,   -82,   106,   112,   150,    74,    32,     0,     0,
+       0,   121,   148,     0,     0,   -82,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,   127,    25,    26,    27,    28,     0,     0,
+      31,     0,     0,     0,     0,   -82,     0,     0,     0,     0,
+      32,     0,     0,     0,     0,   164,     0,     0,   -82,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,     0,    25,    26,    27,
+      28,     0,     0,    31,     0,     0,     0,     0,   -82,     0,
+       0,     0,     0,    32,     0,     0,     0,     0,     6,     0,
+       0,   -82,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,     0,     0,     0,
+       0,     0,   -20,     0,     0,     0,    32,     0,     0,   -20,
+       0,     0,   -20,   -20,     7,     8,     9,    10,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,     0,    25,    26,    27,    28,     0,     0,    31,     0,
+       0,     0,     0,     0,   137,     0,     0,     0,   138,     0,
+       0,     0,     0,     0,    58,   139,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     0,    25,    26,    27,    28,     0,     0,
+      31,     0,     0,     0,     0,   158,     0,     0,     0,     0,
+      32,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,     0,    25,
+      26,    27,    28,     0,     0,    31,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32
+};
+
+static const yytype_int16 yycheck[] =
+{
+      36,    70,    90,     3,     1,    35,     8,    25,   129,    58,
+      31,     1,    28,    30,    30,    17,     0,    31,    35,    95,
+       1,    97,    31,    46,    26,    46,    95,    29,    97,    59,
+      79,    49,    46,    63,    31,    53,   157,    46,    35,    35,
+      35,   129,    39,    42,    43,    35,    35,   116,    45,    46,
+      47,    42,    52,    49,    35,    45,    46,   145,    39,    30,
+      49,    49,   131,    35,    45,    46,    42,    39,    43,   157,
+     139,   140,    29,    45,    46,    42,    43,     1,    50,    44,
+     116,     5,     6,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    35,    23,
+      24,    25,    26,    35,    47,    29,    35,    39,    45,    46,
+      39,    35,    47,    45,    46,    39,    45,    46,    42,    43,
+      47,    45,    46,     1,   139,   140,    50,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    50,    23,    24,    25,    26,    32,
+      42,    29,    42,    44,    28,    42,    44,    35,    34,    48,
+      32,    39,    47,    47,    42,    43,    47,    45,    46,     1,
+      47,     1,    50,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
+      47,    23,    24,    25,    26,    47,    47,    29,    47,    47,
+      47,   145,    34,    72,    84,   131,    52,    39,    -1,    -1,
+      -1,    93,     1,    -1,    -1,    47,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    98,    23,    24,    25,    26,    -1,    -1,
+      29,    -1,    -1,    -1,    -1,    34,    -1,    -1,    -1,    -1,
+      39,    -1,    -1,    -1,    -1,     1,    -1,    -1,    47,     5,
+       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    -1,    23,    24,    25,
+      26,    -1,    -1,    29,    -1,    -1,    -1,    -1,    34,    -1,
+      -1,    -1,    -1,    39,    -1,    -1,    -1,    -1,     1,    -1,
+      -1,    47,     5,     6,     7,     8,     9,    10,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    -1,    -1,    -1,
+      -1,    -1,    35,    -1,    -1,    -1,    39,    -1,    -1,    42,
+      -1,    -1,    45,    46,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    -1,    23,    24,    25,    26,    -1,    -1,    29,    -1,
+      -1,    -1,    -1,    -1,    35,    -1,    -1,    -1,    39,    -1,
+      -1,    -1,    -1,    -1,    45,    46,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    -1,    23,    24,    25,    26,    -1,    -1,
+      29,    -1,    -1,    -1,    -1,    34,    -1,    -1,    -1,    -1,
+      39,     5,     6,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    -1,    23,
+      24,    25,    26,    -1,    -1,    29,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    39
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    52,    53,    54,     0,    53,     1,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    39,    55,    57,    61,    62,    63,    64,    65,
+      66,    70,    81,    93,    95,    42,    43,    30,    35,    35,
+      49,    84,    56,    35,    84,    46,    42,    35,    45,    46,
+      58,    59,    60,    67,    71,    72,    63,    30,    84,     1,
+      61,    85,    86,    87,    57,    61,    84,    35,    68,    69,
+      70,     1,    71,    42,    44,    71,    28,    30,    94,    31,
+      46,    42,    43,    35,    39,    46,    50,    67,    73,    74,
+      88,    89,    90,    91,    43,     1,    87,    71,    47,    70,
+      47,    47,    60,    29,    92,     1,    62,    75,    76,    77,
+      78,    91,     1,    35,    73,    32,    73,    92,    31,    46,
+      42,    44,    42,    48,    82,    83,    47,    35,    39,    46,
+      67,    79,    80,    47,    34,    44,    47,    47,     1,    75,
+      90,    32,     1,    39,    79,    79,    31,    46,    34,    78,
+      47,    47,    47,    47,     1,    75,    47,    47
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+#line 105 "parse.y"
+    { is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; ;}
+    break;
+
+  case 5:
+#line 107 "parse.y"
+    { free_list(*(yyvsp[(2) - (2)]), NULL); *(yyvsp[(2) - (2)]) = NULL; ;}
+    break;
+
+  case 6:
+#line 111 "parse.y"
+    { is_typedef = 1; ;}
+    break;
+
+  case 7:
+#line 112 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 12:
+#line 117 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 13:
+#line 118 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 14:
+#line 123 "parse.y"
+    { if (current_name) {
+		    struct string_list *decl = (*(yyvsp[(3) - (3)]))->next;
+		    (*(yyvsp[(3) - (3)]))->next = NULL;
+		    add_symbol(current_name,
+			       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,
+			       decl, is_extern);
+		    current_name = NULL;
+		  }
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 15:
+#line 136 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 17:
+#line 142 "parse.y"
+    { struct string_list *decl = *(yyvsp[(1) - (1)]);
+		  *(yyvsp[(1) - (1)]) = NULL;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 18:
+#line 150 "parse.y"
+    { struct string_list *decl = *(yyvsp[(3) - (3)]);
+		  *(yyvsp[(3) - (3)]) = NULL;
+		  free_list(*(yyvsp[(2) - (3)]), NULL);
+		  *(yyvsp[(2) - (3)]) = decl_spec;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 19:
+#line 163 "parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]) ? (yyvsp[(4) - (4)]) : (yyvsp[(3) - (4)]) ? (yyvsp[(3) - (4)]) : (yyvsp[(2) - (4)]) ? (yyvsp[(2) - (4)]) : (yyvsp[(1) - (4)]); ;}
+    break;
+
+  case 20:
+#line 168 "parse.y"
+    { decl_spec = NULL; ;}
+    break;
+
+  case 22:
+#line 173 "parse.y"
+    { decl_spec = *(yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 23:
+#line 174 "parse.y"
+    { decl_spec = *(yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 24:
+#line 179 "parse.y"
+    { /* Version 2 checksumming ignores storage class, as that
+		     is really irrelevant to the linkage.  */
+		  if (checksum_version > 1)
+		    remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 29:
+#line 192 "parse.y"
+    { is_extern = 1; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 30:
+#line 193 "parse.y"
+    { is_extern = 0; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 33:
+#line 203 "parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_STRUCT; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 34:
+#line 205 "parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_UNION; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 35:
+#line 207 "parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_ENUM; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 36:
+#line 211 "parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_STRUCT;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_STRUCT, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 37:
+#line 218 "parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_UNION;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_UNION, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 38:
+#line 225 "parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_ENUM;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_ENUM, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 39:
+#line 233 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 40:
+#line 234 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 41:
+#line 235 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 52:
+#line 249 "parse.y"
+    { (*(yyvsp[(1) - (1)]))->tag = SYM_TYPEDEF; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 53:
+#line 254 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 54:
+#line 258 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 57:
+#line 264 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 61:
+#line 270 "parse.y"
+    { /* restrict has no effect in prototypes so ignore it */
+		  remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 62:
+#line 277 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 64:
+#line 283 "parse.y"
+    { if (current_name != NULL) {
+		    error_with_pos("unexpected second declaration name");
+		    YYERROR;
+		  } else {
+		    current_name = (*(yyvsp[(1) - (1)]))->string;
+		    (yyval) = (yyvsp[(1) - (1)]);
+		  }
+		;}
+    break;
+
+  case 65:
+#line 292 "parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 66:
+#line 294 "parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 67:
+#line 296 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 68:
+#line 298 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 69:
+#line 300 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 70:
+#line 306 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 74:
+#line 314 "parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 75:
+#line 316 "parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 76:
+#line 318 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 77:
+#line 320 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 78:
+#line 322 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 79:
+#line 326 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 81:
+#line 328 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 82:
+#line 332 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 85:
+#line 339 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 86:
+#line 344 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 87:
+#line 349 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 89:
+#line 354 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 90:
+#line 356 "parse.y"
+    { /* For version 2 checksums, we don't want to remember
+		     private parameter names.  */
+		  if (checksum_version > 1)
+		    remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 91:
+#line 365 "parse.y"
+    { if (checksum_version > 1)
+		    remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 92:
+#line 370 "parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 93:
+#line 372 "parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 94:
+#line 374 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 95:
+#line 376 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 96:
+#line 378 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 97:
+#line 383 "parse.y"
+    { struct string_list *decl = *(yyvsp[(2) - (3)]);
+		  *(yyvsp[(2) - (3)]) = NULL;
+		  add_symbol(current_name, SYM_NORMAL, decl, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 98:
+#line 391 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 100:
+#line 398 "parse.y"
+    { remove_list((yyvsp[(2) - (2)]), &(*(yyvsp[(1) - (2)]))->next); (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 101:
+#line 402 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 102:
+#line 403 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 103:
+#line 407 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 106:
+#line 413 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 107:
+#line 418 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 108:
+#line 420 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 109:
+#line 424 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 112:
+#line 430 "parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 113:
+#line 434 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 114:
+#line 435 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 116:
+#line 440 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 117:
+#line 444 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 119:
+#line 449 "parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 120:
+#line 453 "parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 122:
+#line 459 "parse.y"
+    { export_symbol((*(yyvsp[(3) - (5)]))->string); (yyval) = (yyvsp[(5) - (5)]); ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 2100 "parse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+#line 463 "parse.y"
+
+
+static void
+yyerror(const char *e)
+{
+  error_with_pos("%s", e);
+}
+
diff -urN linux-2.4.37.11-orig//modutils/parse.h linux-2.4.37.11-rescue//modutils/parse.h
--- linux-2.4.37.11-orig//modutils/parse.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/parse.h	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,135 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     FLOAT_KEYW = 267,
+     INLINE_KEYW = 268,
+     INT_KEYW = 269,
+     LONG_KEYW = 270,
+     REGISTER_KEYW = 271,
+     RESTRICT_KEYW = 272,
+     SHORT_KEYW = 273,
+     SIGNED_KEYW = 274,
+     STATIC_KEYW = 275,
+     STRUCT_KEYW = 276,
+     TYPEDEF_KEYW = 277,
+     UNION_KEYW = 278,
+     UNSIGNED_KEYW = 279,
+     VOID_KEYW = 280,
+     VOLATILE_KEYW = 281,
+     EXPORT_SYMBOL_KEYW = 282,
+     ASM_PHRASE = 283,
+     ATTRIBUTE_PHRASE = 284,
+     BRACE_PHRASE = 285,
+     BRACKET_PHRASE = 286,
+     EXPRESSION_PHRASE = 287,
+     CHAR = 288,
+     DOTS = 289,
+     IDENT = 290,
+     INT = 291,
+     REAL = 292,
+     STRING = 293,
+     TYPE = 294,
+     OTHER = 295,
+     FILENAME = 296
+   };
+#endif
+/* Tokens.  */
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define FLOAT_KEYW 267
+#define INLINE_KEYW 268
+#define INT_KEYW 269
+#define LONG_KEYW 270
+#define REGISTER_KEYW 271
+#define RESTRICT_KEYW 272
+#define SHORT_KEYW 273
+#define SIGNED_KEYW 274
+#define STATIC_KEYW 275
+#define STRUCT_KEYW 276
+#define TYPEDEF_KEYW 277
+#define UNION_KEYW 278
+#define UNSIGNED_KEYW 279
+#define VOID_KEYW 280
+#define VOLATILE_KEYW 281
+#define EXPORT_SYMBOL_KEYW 282
+#define ASM_PHRASE 283
+#define ATTRIBUTE_PHRASE 284
+#define BRACE_PHRASE 285
+#define BRACKET_PHRASE 286
+#define EXPRESSION_PHRASE 287
+#define CHAR 288
+#define DOTS 289
+#define IDENT 290
+#define INT 291
+#define REAL 292
+#define STRING 293
+#define TYPE 294
+#define OTHER 295
+#define FILENAME 296
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
diff -urN linux-2.4.37.11-orig//modutils/snap_shot.c linux-2.4.37.11-rescue//modutils/snap_shot.c
--- linux-2.4.37.11-orig//modutils/snap_shot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/snap_shot.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,156 @@
+/* Take a snap shot of ksyms and modules for Oops debugging
+   Copyright 1999 Linux International.
+
+   Contributed by Keith Owens <kaos@ocs.com.au>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+  */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "module.h"
+#include "obj.h"
+#include "modstat.h"
+#include "util.h"
+
+static char snap_dir[] = "/var/log/ksymoops";
+
+/* If snap_dir exists, take a snap shot of ksyms and modules to snap_dir.
+ * Prefix the files with the equivalent of
+ * date +%Y%m%d%T%M%S | sed -e 's/://g'
+ */
+void snap_shot(const char *module_names, int n_module_names)
+{
+	char file[] = "ccyymmddhhmmss.modules", buffer[4096];
+	static char *infile[] = { "/proc/ksyms", "/proc/modules" };
+	static char *suffix[] = {       "ksyms",       "modules" };
+	struct tm *local;
+	time_t t;
+	int i, l;
+	FILE *in, *out;
+
+	if (module_names) {
+		/* Only snap shot if the list of modules has changed.
+		 * Otherwise auto cleanup takes a snap shot every time
+		 * and ends up with a large snap shot directory.
+		 */
+		char *new_module_names;
+		size_t n_new_module_names;
+		get_kernel_info(0);
+		new_module_names = module_name_list;
+		n_new_module_names = n_module_stat;
+		if (n_module_names && n_new_module_names == n_module_names) {
+			while (n_module_names) {
+				if (strcmp(module_names, new_module_names))
+					break;	/* difference detected */
+				i = strlen(module_names) + 1;
+				module_names += i;
+				new_module_names += i;
+				--n_module_names;
+			}
+		}
+		if (!n_module_names)
+			return;	/* no difference, no need for snap shot */
+	}
+
+	if (chdir(snap_dir))
+		return;
+	t = time(NULL);
+	local = localtime(&t);
+	for (i = 0; i < sizeof(infile)/sizeof(infile[0]); ++i) {
+		snprintf(file, sizeof(file), "%04d%02d%02d%02d%02d%02d.%s",
+			local->tm_year+1900,
+			local->tm_mon + 1,
+			local->tm_mday,
+			local->tm_hour,
+			local->tm_min,
+			local->tm_sec,
+			suffix[i]);
+		out = fopen(file, "w");
+		if (!out) {
+			error("cannot create %s/%s %m", snap_dir, file);
+			return;
+		}
+		in = fopen(infile[i], "r");
+		if (!in) {
+			error("cannot open %s %m", infile[i]);
+			return;
+		}
+		while ((l = fread(buffer, 1, sizeof(buffer), in)) > 0) {
+			if (fwrite(buffer, l, 1, out) != 1) {
+				error("unable to write to %s %m", file);
+				fclose(in);
+				fclose(out);
+				return;
+			}
+		}
+		if (ferror(in))
+			error("unable to read from %s %m", infile[i]);
+		fclose(in);
+		fflush(out);
+		fdatasync(fileno(out));
+		fclose(out);
+	}
+}
+
+/* If snap_dir exists, log a message to snap_dir.  The log file is called the
+ * equivalent of date +%Y%m%d | sed -e 's/://g'.  Each line is prefixed with
+ * timestamp down to seconds and followed by a newline.
+ */
+void snap_shot_log(const char *fmt,...)
+{
+	char date[] = "ccyymmdd", file[] = "ccyymmdd.log", stamp[] = "ccyymmdd hhmmss";
+	struct tm *local;
+	time_t t;
+	FILE *log;
+	va_list args;
+	int save_errno = errno;
+
+	if (chdir(snap_dir))
+		return;
+	t = time(NULL);
+	local = localtime(&t);
+	snprintf(date, sizeof(date), "%04d%02d%02d",
+			local->tm_year+1900,
+			local->tm_mon + 1,
+			local->tm_mday);
+	snprintf(file, sizeof(file), "%s.log", date);
+	log = fopen(file, "a");
+	if (!log) {
+		error("cannot create %s/%s %m", snap_dir, file);
+		return;
+	}
+	snprintf(stamp, sizeof(stamp), "%s %02d%02d%02d",
+		date,
+		local->tm_hour,
+		local->tm_min,
+		local->tm_sec);
+	fprintf(log, "%s ", stamp);
+	va_start(args, fmt);
+	errno = save_errno;	/* fmt may use %m */
+	vfprintf(log, fmt, args);
+	va_end(args);
+	fprintf(log, "\n");
+	fflush(log);
+	fdatasync(fileno(log));
+	fclose(log);
+}
diff -urN linux-2.4.37.11-orig//modutils/sys_nim.c linux-2.4.37.11-rescue//modutils/sys_nim.c
--- linux-2.4.37.11-orig//modutils/sys_nim.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/sys_nim.c	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,51 @@
+/* Functions for the Linux module syscall interface.
+   Copyright 1996, 1997 Linux International.
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdlib.h>
+#include <errno.h>
+
+#include "module.h"
+
+/* Kernel headers before 2.1.mumble need this on the Alpha to get
+   _syscall* defined.  */
+#define __LIBRARY__
+
+#include <asm/unistd.h>
+
+
+/*======================================================================*/
+
+#ifndef CONFIG_USE_SYSCALL
+
+extern int init_module(const char *name, const struct module *info);
+
+int
+sys_init_module(const char *name, const struct module *info)
+{
+  return init_module(name, info);
+}
+
+#else
+
+#define __NR_sys_init_module  __NR_init_module
+_syscall2(int, sys_init_module, const char *, name,
+	  const struct module *, info)
+
+#endif
diff -urN linux-2.4.37.11-orig//modutils/util.h linux-2.4.37.11-rescue//modutils/util.h
--- linux-2.4.37.11-orig//modutils/util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/util.h	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1,103 @@
+#ifndef MODUTILS_UTIL_H
+#define MODUTILS_UTIL_H 1
+
+/* Miscelaneous utility functions.
+   Copyright 1996, 1997 Linux International.
+
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+#include <stdio.h>
+#include <sys/stat.h>
+
+#define SHELL_META "&();|<>$`\"'\\!{}[]~=+:?*" /* Sum of bj0rn and Debian */
+
+void *xmalloc(size_t);
+void *xrealloc(void *, size_t);
+char *xstrdup(const char *);
+char *xstrcat(char *, const char *, size_t);
+int   xsystem(const char *, char *const[]);
+int   arch64(void);
+
+typedef int (*xftw_func_t)(const char *, const struct stat *);
+extern int xftw(const char *directory, xftw_func_t);
+
+/* Error logging */
+//extern int log;
+//extern int errors;
+extern const char *error_file;
+
+extern int flag_verbose;
+extern void verbose(const char *ctl,...);
+
+void error(const char *fmt, ...)
+#ifdef __GNUC__
+  __attribute__((format(printf, 1, 2)))
+#endif
+  ;
+
+void lprintf(const char *fmt, ...)
+#ifdef __GNUC__
+  __attribute__((format(printf, 1, 2)))
+#endif
+  ;
+
+void setsyslog(const char *program);
+
+/*
+ * Generic globlist <bj0rn@blox.se>
+ */
+typedef struct {
+	int pathc;       /* Count of paths matched so far  */
+	char **pathv;    /* List of matched pathnames.  */
+} GLOB_LIST;
+int meta_expand(char *pt, GLOB_LIST *g, char *base_dir, char *version, int type);
+#define ME_BUILTIN_COMMAND	1
+#define ME_SHELL_COMMAND	2
+#define ME_GLOB			4
+#define ME_ALL			(ME_GLOB|ME_SHELL_COMMAND|ME_BUILTIN_COMMAND)
+
+extern void snap_shot(const char *module_name, int number);
+extern void snap_shot_log(const char *fmt,...);
+
+#ifdef CONFIG_USE_ZLIB
+int gzf_open(const char *name, int mode);
+int gzf_read(int fd, void *buf, size_t count);
+off_t gzf_lseek(int fd, off_t offset, int whence);
+void gzf_close(int fd);
+
+#else /* ! CONFIG_USE_ZLIB */
+
+#include <unistd.h>
+
+#define gzf_open	open
+#define gzf_read	read
+#define gzf_lseek	lseek
+#define gzf_close	close
+
+#endif /* CONFIG_USE_ZLIB */
+
+#define SYMPREFIX "__insmod_";
+extern const char symprefix[10];	/* Must be sizeof(SYMPREFIX), including nul */
+
+#if defined(ARCH_ia64) || defined(ARCH_ppc64) || defined(ARCH_hppa) || defined(ARCH_hppa64)
+#define HAS_FUNCTION_DESCRIPTORS
+#endif
+
+#endif /* util.h */
diff -urN linux-2.4.37.11-orig//modutils/version.h linux-2.4.37.11-rescue//modutils/version.h
--- linux-2.4.37.11-orig//modutils/version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/version.h	2010-12-31 14:20:29.077585832 +0100
@@ -0,0 +1 @@
+#define MODUTILS_VERSION "2.4.26"
diff -urN linux-2.4.37.11-orig//modutils/xftw.c linux-2.4.37.11-rescue//modutils/xftw.c
--- linux-2.4.37.11-orig//modutils/xftw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/xftw.c	2010-12-31 14:20:29.081585552 +0100
@@ -0,0 +1,422 @@
+/*
+ * modutils specific implementation of ftw().
+ *
+ * Copyright 2000:
+ *  Keith Owens <kaos@ocs.com.au> August 2000
+ *
+ * This file is part of the Linux modutils.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/*
+    modutils requires special processing during the file tree walk
+    of /lib/modules/<version> and any paths that the user specifies.
+    The standard ftw() does a blind walk of all paths and can end
+    up following the build symlink down the kernel source tree.
+    Although nftw() has the option to get more control such as not
+    automatically following symbolic links, even that is not enough
+    for modutils.  The requirements are:
+
+    Paths must be directories or symlinks to directories.
+
+    Each directory is read and sorted into alphabetical order
+    before processing.
+
+    A directory is type 1 iff it was specified on a path statement
+    (either explicit or default) and the directory contains a
+    subdirectory with one of the known names and the directory name
+    does not end with "/kernel".  Otherwise it is type 2.
+
+    In a type 1 directory, walk the kernel subdirectory if it exists,
+    then the old known names in their historical order then any
+    remaining directory entries in alphabetical order and finally any
+    non-directory entries in alphabetical order.
+
+    Entries in a type 1 directory are filtered against the "prune"
+    list.  A type 1 directory can contain additional files which
+    are not modules nor symlinks to modules.  The prune list skips
+    known additional files, if a distribution wants to store
+    additional text files in the top level directory they should be
+    added to the prune list.
+
+    A type 2 directory must contain only modules or symlinks to
+    modules.  They are processed in alphabetical order, without
+    pruning.  Symlinks to directories are an error in type 2
+    directories.
+
+    The user function is not called for type 1 directories, nor for
+    pruned entries.  It is called for type 2 directories and their
+    contents.  It is also called for any files left in a type 1
+    directory after pruning and processing type 2 subdirectories.
+    The user function never sees symlinks, they are resolved before
+    calling the function.
+
+    Why have different directory types?  The original file tree
+    walk was not well defined.  Some users specified each directory
+    individually, others just pointed at the top level directory.
+    Either version worked until the "build" symlink was added.  Now
+    users who specify the top level directory end up running the
+    entire kernel source tree looking for modules, not nice.  We
+    cannot just ignore symlinks because pcmcia uses symlinks to
+    modules for backwards compatibility.
+
+    Type 1 is when a user specifies the top level directory which needs
+    special processing, type 2 is individual subdirectories.  But the
+    only way to tell the difference is by looking at the contents.  The
+    "/kernel" directory introduced in 2.3.12 either contains nothing
+    (old make modules_install) or contains all the kernel modules using
+    the same tree structure as the source.  Because "/kernel" can
+    contain old names but is really a type 2 directory, it is detected
+    as a special case.
+ */
+
+#include <dirent.h>
+#include <errno.h>
+#include <limits.h>
+#include <malloc.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include "util.h"
+#include "config.h"
+
+extern char *tbpath[];
+
+extern OPT_LIST *prune_list;
+extern int n_prune_list;
+
+extern char *tbtype[];
+
+struct xftw_dirent {
+    struct stat statbuf;
+    char *name;
+    char *fullname;
+};
+
+#define XFTW_MAXDEPTH 64    /* Maximum directory depth handled */
+
+typedef struct {
+    struct xftw_dirent *contents;
+    int size;
+    int used;
+} xftw_tree_t;
+
+static xftw_tree_t tree[XFTW_MAXDEPTH];
+
+/* Free all data for one tree level */
+static void xftw_free_tree(int depth)
+{
+    int i;
+    xftw_tree_t *t = tree+depth;
+    for (i = 0; i < t->size; ++i) {
+	free(t->contents[i].name);
+	free(t->contents[i].fullname);
+    }
+    free(t->contents);
+    t->contents = NULL;
+    t->size = 0;
+    t->used = 0;
+}
+
+/* Increment dirents used at this depth, resizing if necessary */
+static void xftw_add_dirent(int depth)
+{
+    xftw_tree_t *t = tree+depth;
+    int i, size = t->size;
+    if (++t->used < size)
+	return;
+    size += 10; /* arbitrary increment */
+    t->contents = xrealloc(t->contents, size*sizeof(*(t->contents)));
+    for (i = t->size; i < size; ++i) {
+	memset(&(t->contents[i].statbuf), 0, sizeof(t->contents[i].statbuf));
+	t->contents[i].name = NULL;
+	t->contents[i].fullname = NULL;
+    }
+    t->size = size;
+}
+
+/* Concatenate directory name and entry name into one string.
+ * Note: caller must free result or leak.
+ */
+static char *xftw_dir_name(const char *directory, const char *entry)
+{
+    int i = strlen(directory);
+    char *name;
+    if (entry)
+	i += strlen(entry);
+    i += 2;
+    name = xmalloc(i);
+    strcpy(name, directory);	/* safe, xmalloc */
+    if (*directory && entry)
+	strcat(name, "/");	/* safe, xmalloc */
+    if (entry)
+	strcat(name, entry);	/* safe, xmalloc */
+    return(name);
+}
+
+/* Call the user function for a directory entry */
+static int xftw_do_name(const char *directory, const char *entry, struct stat *sb, xftw_func_t funcptr)
+{
+    int ret = 0;
+    char *name = xftw_dir_name(directory, entry);
+
+    if (S_ISLNK(sb->st_mode)) {
+	char real[PATH_MAX], *newname;
+	verbose("resolving %s symlink to ", name);
+	if (!(newname = realpath(name, real))) {
+	    if (errno == ENOENT) {
+		verbose("%s: does not exist, dangling symlink ignored\n", real);
+		goto cleanup;
+	    }
+	    perror("... failed");
+	    goto cleanup;
+	}
+	verbose("%s ", newname);
+	if (lstat(newname, sb)) {
+	    error("lstat on %s failed ", newname);
+	    perror("");
+	    goto cleanup;
+	}
+	free(name);
+	name = xstrdup(newname);
+    }
+
+    if (!S_ISREG(sb->st_mode) &&
+	!S_ISDIR(sb->st_mode)) {
+	error("%s is not plain file nor directory\n", name);
+	goto cleanup;
+    }
+	
+    verbose("user function %s\n", name);
+    ret = (*funcptr)(name, sb);
+cleanup:
+    free(name);
+    return(ret);
+}
+
+/* Sort directory entries into alphabetical order */
+static int xftw_sortdir(const void *a, const void *b)
+{
+    return(strcmp(((struct xftw_dirent *)a)->name, ((struct xftw_dirent *)b)->name));
+}
+
+/* Read a directory and sort it, ignoring "." and ".." */
+static int xftw_readdir(const char *directory, int depth)
+{
+    DIR *d;
+    struct dirent *ent;
+    verbose("xftw_readdir %s\n", directory);
+    if (!(d = opendir(directory))) {
+	perror(directory);
+	return(1);
+    }
+    while ((ent = readdir(d))) {
+	char *name;
+	struct xftw_dirent *f;
+	if (strcmp(ent->d_name, ".") == 0 ||
+	    strcmp(ent->d_name, "..") == 0)
+	    continue;
+	name = xftw_dir_name(directory, ent->d_name);
+	xftw_add_dirent(depth);
+	f = tree[depth].contents+tree[depth].used-1;
+	f->name = xstrdup(ent->d_name);
+	f->fullname = name;     /* do not free name, it is in use */
+	if (lstat(name, &(f->statbuf))) {
+	    perror(name);
+	    return(1);
+	}
+    }
+    closedir(d);
+    qsort(tree[depth].contents, tree[depth].used, sizeof(*(tree[0].contents)), &xftw_sortdir);
+    return(0);
+}
+
+/* Process a type 2 directory */
+int xftw_type2(const char *directory, const char *entry, int depth, xftw_func_t funcptr)
+{
+    int ret, i;
+    xftw_tree_t *t = tree+depth;
+    struct stat statbuf;
+    char *dirname = xftw_dir_name(directory, entry);
+
+    verbose("type 2 %s\n", dirname);
+    if (depth > XFTW_MAXDEPTH) {
+	error("xftw_type2 exceeded maxdepth\n");
+	ret = 1;
+	goto cleanup;
+    }
+    if ((ret = xftw_readdir(dirname, depth)))
+	goto cleanup;
+
+    t = tree+depth;
+    /* user function sees type 2 directories */
+    if ((ret = lstat(dirname, &statbuf)) ||
+	(ret = xftw_do_name("", dirname, &statbuf, funcptr)))
+	goto cleanup;
+
+    /* user sees all contents of type 2 directory, no pruning */
+    for (i = 0; i < t->used; ++i) {
+	struct xftw_dirent *c = t->contents+i;
+	if (S_ISLNK(c->statbuf.st_mode)) {
+	    if (!stat(c->name, &(c->statbuf))) {
+		if (S_ISDIR(c->statbuf.st_mode)) {
+		    error("symlink to directory is not allowed, %s ignored\n", c->name);
+		    *(c->name) = '\0';  /* ignore it */
+		}
+	    }
+	}
+	if (!*(c->name))
+	    continue;
+	if (S_ISDIR(c->statbuf.st_mode)) {
+	    /* recursion is the curse of the programming classes */
+	    ret = xftw_type2(dirname, c->name, depth+1, funcptr);
+	    if (ret)
+		goto cleanup;
+	}
+	else if ((ret = xftw_do_name(dirname, c->name, &(c->statbuf), funcptr)))
+	    goto cleanup;
+	*(c->name) = '\0';  /* processed */
+    }
+
+    ret = 0;
+cleanup:
+    free(dirname);
+    return(ret);
+}
+
+/* Only external visible function.  Decide on the type of directory and
+ * process accordingly.
+ */
+int xftw(const char *directory, xftw_func_t funcptr)
+{
+    struct stat statbuf;
+    int ret, i, j, type;
+    xftw_tree_t *t;
+    struct xftw_dirent *c;
+
+    verbose("xftw starting at %s ", directory);
+    if (lstat(directory, &statbuf)) {
+	verbose("lstat on %s failed\n", directory);
+	return(0);
+    }
+    if (S_ISLNK(statbuf.st_mode)) {
+	char real[PATH_MAX];
+	verbose("resolving symlink to ");
+	if (!(directory = realpath(directory, real))) {
+	    if (errno == ENOENT) {
+		verbose("%s: does not exist, dangling symlink ignored\n", real);
+		return(0);
+	    }
+	    perror("... failed");
+	    return(-1);
+	}
+	verbose("%s ", directory);
+	if (lstat(directory, &statbuf)) {
+	    error("lstat on %s failed ", directory);
+	    perror("");
+	    return(-1);
+	}
+    }
+    if (!S_ISDIR(statbuf.st_mode)) {
+	error("%s is not a directory\n", directory);
+	return(-1);
+    }
+    verbose("\n");
+
+    /* All returns after this point must be via cleanup */
+
+    if ((ret = xftw_readdir(directory, 0)))
+	goto cleanup;
+
+    t = tree;   /* depth 0 */
+    type = 2;
+    for (i = 0 ; type == 2 && i < t->used; ++i) {
+	c = t->contents+i;
+	for (j = 0; tbtype[j]; ++j) {
+	    if (strcmp(c->name, tbtype[j]) == 0 &&
+		S_ISDIR(c->statbuf.st_mode)) {
+		const char *p = directory + strlen(directory) - 1;
+		if (*p == '/')
+		    --p;
+		if (p - directory >= 6 && strncmp(p-6, "/kernel", 7) == 0)
+		    continue;	/* "/kernel" path is a special case, type 2 */
+		type = 1;   /* known subdirectory */
+		break;
+	    }
+	}
+    }
+
+    if (type == 1) {
+	OPT_LIST *p;
+	/* prune entries in type 1 directories only */
+	for (i = 0 ; i < t->used; ++i) {
+	    for (p = prunelist; p->name; ++p) {
+		c = t->contents+i;
+		if (strcmp(p->name, c->name) == 0) {
+		    verbose("pruned %s\n", c->name);
+		    *(c->name) = '\0';  /* ignore */
+		}
+	    }
+	}
+	/* run known subdirectories first in historical order, "kernel" is now top of list */
+        for (j = 0; tbtype[j]; ++j) {
+	    for (i = 0 ; i < t->used; ++i) {
+	        c = t->contents+i;
+		if (*(c->name) &&
+		    strcmp(c->name, tbtype[j]) == 0 &&
+		    S_ISDIR(c->statbuf.st_mode)) {
+		    if ((ret = xftw_type2(directory, c->name, 1, funcptr)))
+			goto cleanup;
+		    *(c->name) = '\0';  /* processed */
+		}
+	    }
+	}
+	/* any other directories left, in alphabetical order */
+	for (i = 0 ; i < t->used; ++i) {
+	    c = t->contents+i;
+	    if (*(c->name) &&
+	        S_ISDIR(c->statbuf.st_mode)) {
+		if ((ret = xftw_type2(directory, c->name, 1, funcptr)))
+		    goto cleanup;
+		*(c->name) = '\0';  /* processed */
+	    }
+	}
+	/* anything else is passed to the user function */
+	for (i = 0 ; i < t->used; ++i) {
+	    c = t->contents+i;
+	    if (*(c->name)) {
+		verbose("%s found in type 1 directory %s\n", c->name, directory);
+		if ((ret = xftw_do_name(directory, c->name, &(c->statbuf), funcptr)))
+		    goto cleanup;
+		*(c->name) = '\0';  /* processed */
+	    }
+	}
+    }
+    else {
+	/* type 2 */
+	xftw_free_tree(0);
+	if ((ret = xftw_type2(directory, NULL, 0, funcptr)))
+	    goto cleanup;
+    }
+
+    /* amazing, it all worked */
+    ret = 0;
+cleanup:
+    for (i = 0; i < XFTW_MAXDEPTH; ++i)
+	xftw_free_tree(i);
+    return(ret);
+}
diff -urN linux-2.4.37.11-orig//modutils/xmalloc.c linux-2.4.37.11-rescue//modutils/xmalloc.c
--- linux-2.4.37.11-orig//modutils/xmalloc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/xmalloc.c	2010-12-31 14:20:29.081585552 +0100
@@ -0,0 +1,37 @@
+/* Misc utility functions.
+   Copyright 1996, 1997 Linux International.
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdlib.h>
+#include "util.h"
+
+
+/*======================================================================*/
+
+void *
+xmalloc(size_t size)
+{
+  void *ptr = malloc(size ? size : 1);
+  if (!ptr)
+    {
+      error("Out of memory");
+      exit(1);
+    }
+  return ptr;
+}
diff -urN linux-2.4.37.11-orig//modutils/xrealloc.c linux-2.4.37.11-rescue//modutils/xrealloc.c
--- linux-2.4.37.11-orig//modutils/xrealloc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/xrealloc.c	2010-12-31 14:20:29.081585552 +0100
@@ -0,0 +1,37 @@
+/* Misc utility functions.
+   Copyright 1996, 1997 Linux International.
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdlib.h>
+#include "util.h"
+
+
+/*======================================================================*/
+
+void *
+xrealloc(void *old, size_t size)
+{
+  void *ptr = realloc(old, size);
+  if (!ptr)
+    {
+      error("Out of memory");
+      exit(1);
+    }
+  return ptr;
+}
diff -urN linux-2.4.37.11-orig//modutils/xstrcat.c linux-2.4.37.11-rescue//modutils/xstrcat.c
--- linux-2.4.37.11-orig//modutils/xstrcat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/xstrcat.c	2010-12-31 14:20:29.081585552 +0100
@@ -0,0 +1,38 @@
+/* Misc utility functions.
+   Copyright 2000 Keith Owens <kaos@ocs.com.au>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include "util.h"
+
+
+/*======================================================================*/
+
+char *
+xstrcat(char *dest, const char *src, size_t size)
+{
+  int ldest = strlen(dest);
+  int lsrc = strlen(src);
+  if ((size - ldest - 1) < lsrc) {
+    error("xstrcat: destination overflow");
+    exit(1);
+  }
+  memcpy(dest+ldest, src, lsrc+1);
+  return(dest);
+}
diff -urN linux-2.4.37.11-orig//modutils/xstrdup.c linux-2.4.37.11-rescue//modutils/xstrdup.c
--- linux-2.4.37.11-orig//modutils/xstrdup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/xstrdup.c	2010-12-31 14:20:29.081585552 +0100
@@ -0,0 +1,39 @@
+/* Misc utility functions.
+   Copyright 1996, 1997 Linux International.
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "util.h"
+
+
+/*======================================================================*/
+
+char *
+xstrdup(const char *s)
+{
+  char *n = strdup(s);
+  if (!n)
+    {
+      error("Out of memory");
+      exit(1);
+    }
+  return n;
+}
diff -urN linux-2.4.37.11-orig//modutils/xsystem.c linux-2.4.37.11-rescue//modutils/xsystem.c
--- linux-2.4.37.11-orig//modutils/xsystem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37.11-rescue//modutils/xsystem.c	2010-12-31 14:20:29.081585552 +0100
@@ -0,0 +1,49 @@
+/* Misc utility functions.
+   Copyright 2000 Keith Owens <kaos@ocs.com.au>
+
+   This file is part of the Linux modutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <unistd.h>
+
+
+/*======================================================================*/
+
+/* Clone of the system() function From Steven's Advanced Programming in a Unix
+ * Environment.  Modified to use *argv[] and execvp to avoid shell expansion
+ * problems, modutils runs as root so system() is unsafe.
+ */
+
+int
+xsystem(const char *file, char *const argv[])
+{
+  pid_t pid;
+  int status;
+  if ((pid = fork()) < 0)
+    return(-1);
+  if (pid == 0) {
+    execvp(file, argv);
+    _exit(127);
+  }
+  while (waitpid(pid, &status, 0) < 0) {
+    if (errno != EINTR)
+      return(-1);
+  }
+  return(status);
+}
